!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module oas_main_d
  implicit none

contains
!  differentiation of manipulate_mesh_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: mesh
!   with respect to varying inputs: span yshear taper sweep chord
!                twist dihedral xshear zshear
!   rw status of diff variables: span:in yshear:in taper:in sweep:in
!                chord:in mesh:out twist:in dihedral:in xshear:in
!                zshear:in
  subroutine manipulate_mesh_main_d(nx, ny, input_mesh, taper, taperd, &
&   chord, chordd, sweep, sweepd, xshear, xsheard, span, spand, yshear, &
&   ysheard, dihedral, dihedrald, zshear, zsheard, twist, twistd, &
&   symmetry, rotate_x, mesh, meshd)
    implicit none
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: input_mesh(nx, ny, 3), taper, chord(ny)
    real(kind=8), intent(in) :: taperd, chordd(ny)
    real(kind=8), intent(in) :: sweep, xshear(ny), span, yshear(ny)
    real(kind=8), intent(in) :: sweepd, xsheard(ny), spand, ysheard(ny)
    real(kind=8), intent(in) :: dihedral, zshear(ny), twist(ny)
    real(kind=8), intent(in) :: dihedrald, zsheard(ny), twistd(ny)
    logical, intent(in) :: symmetry, rotate_x
    real(kind=8), intent(out) :: mesh(nx, ny, 3)
    real(kind=8), intent(out) :: meshd(nx, ny, 3)
    real(kind=8) :: le(ny, 3), te(ny, 3), quarter_chord(ny, 3), p180, &
&   tan_theta
    real(kind=8) :: led(ny, 3), ted(ny, 3), quarter_chordd(ny, 3), &
&   tan_thetad
    real(kind=8) :: dx(ny), y0, rad_twist(ny), rotation_matrix(ny, 3, 3)
    real(kind=8) :: dxd(ny), y0d, rad_twistd(ny), rotation_matrixd(ny, 3&
&   , 3)
    real(kind=8) :: row(ny, 3), out(3), taper_lins(ny), taper_lins_sym((&
&   ny+1)/2)
    real(kind=8) :: rowd(ny, 3), outd(3), taper_linsd(ny)
    real(kind=8) :: rad_theta_x(ny), one, dz_qc(ny-1), dy_qc(ny-1), s(ny&
&   ), new_span
    real(kind=8) :: rad_theta_xd(ny), dz_qcd(ny-1), dy_qcd(ny-1), sd(ny)&
&   , new_spand
    real(kind=8) :: dz_qc_l((ny-1)/2), dz_qc_r((ny-1)/2), dy_qc_l((ny-1)&
&   /2), dy_qc_r((ny-1)/2)
    real(kind=8) :: dz_qc_ld((ny-1)/2), dz_qc_rd((ny-1)/2), dy_qc_ld((ny&
&   -1)/2), dy_qc_rd((ny-1)/2)
    real(kind=8) :: computed_span
    integer :: ny2, ix, iy, ind
    intrinsic tan
    intrinsic atan
    intrinsic cos
    intrinsic sin
    p180 = 3.14159265358979323846264338/180.
    mesh = input_mesh
    one = 1.
! taper
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    quarter_chord = 0.25*te + 0.75*le
    if (symmetry) then
      computed_span = quarter_chord(ny, 2) - quarter_chord(1, 2)
      taper_linsd = 0.0_8
      do iy=1,ny
        taper_linsd(iy) = taperd - (quarter_chord(iy, 2)-quarter_chord(1&
&         , 2))*taperd/computed_span
        taper_lins(iy) = (quarter_chord(iy, 2)-quarter_chord(1, 2))/&
&         computed_span*(1-taper) + taper
      end do
      meshd = 0.0_8
      do iy=1,ny
        do ix=1,nx
          do ind=1,3
            meshd(ix, iy, ind) = meshd(ix, iy, ind)*taper_lins(iy) + (&
&             mesh(ix, iy, ind)-quarter_chord(iy, ind))*taper_linsd(iy)
            mesh(ix, iy, ind) = (mesh(ix, iy, ind)-quarter_chord(iy, ind&
&             ))*taper_lins(iy) + quarter_chord(iy, ind)
          end do
        end do
      end do
      dxd = 0.0_8
    else
      computed_span = quarter_chord(ny, 2) - quarter_chord(1, 2)
      ny2 = (ny-1)/2
      dxd = 0.0_8
      do iy=1,ny2
        dxd(iy) = quarter_chord(iy, 2)*2*taperd/computed_span
        dx(iy) = 1 + quarter_chord(iy, 2)/(computed_span/2)*taper
      end do
      do iy=1,ny2
        dxd(iy) = taperd - (quarter_chord(iy, 2)-quarter_chord(1, 2))*2*&
&         taperd/computed_span
        dx(iy) = (quarter_chord(iy, 2)-quarter_chord(1, 2))/(&
&         computed_span/2)*(1-taper) + taper
      end do
      do iy=ny,ny2+1,-1
        dxd(iy) = (quarter_chord(iy, 2)-quarter_chord(ny, 2))*2*taperd/&
&         computed_span + taperd
        dx(iy) = -((quarter_chord(iy, 2)-quarter_chord(ny, 2))/(&
&         computed_span/2)*(1-taper)) + taper
      end do
      meshd = 0.0_8
      do iy=1,ny
        do ix=1,nx
          do ind=1,3
            meshd(ix, iy, ind) = meshd(ix, iy, ind)*dx(iy) + (mesh(ix, &
&             iy, ind)-quarter_chord(iy, ind))*dxd(iy)
            mesh(ix, iy, ind) = (mesh(ix, iy, ind)-quarter_chord(iy, ind&
&             ))*dx(iy) + quarter_chord(iy, ind)
          end do
        end do
      end do
    end if
! scale x
    led = meshd(1, :, :)
    le = mesh(1, :, :)
    ted = meshd(nx, :, :)
    te = mesh(nx, :, :)
    quarter_chordd = 0.25*ted + 0.75*led
    quarter_chord = 0.25*te + 0.75*le
    do iy=1,ny
      meshd(:, iy, 1) = (meshd(:, iy, 1)-quarter_chordd(iy, 1))*chord(iy&
&       ) + (mesh(:, iy, 1)-quarter_chord(iy, 1))*chordd(iy) + &
&       quarter_chordd(iy, 1)
      mesh(:, iy, 1) = (mesh(:, iy, 1)-quarter_chord(iy, 1))*chord(iy) +&
&       quarter_chord(iy, 1)
    end do
! sweep
    led = meshd(1, :, :)
    le = mesh(1, :, :)
    tan_thetad = p180*sweepd*(1.0+tan(p180*sweep)**2)
    tan_theta = tan(p180*sweep)
    if (symmetry) then
      y0d = led(ny, 2)
      y0 = le(ny, 2)
      dxd = -((led(:, 2)-y0d)*tan_theta+(le(:, 2)-y0)*tan_thetad)
      dx = -((le(:, 2)-y0)*tan_theta)
    else
      ny2 = (ny-1)/2
      y0d = led(ny2+1, 2)
      y0 = le(ny2+1, 2)
      dxd(:ny2) = -((led(:ny2, 2)-y0d)*tan_theta+(le(:ny2, 2)-y0)*&
&       tan_thetad)
      dx(:ny2) = -((le(:ny2, 2)-y0)*tan_theta)
      dxd(ny2+1:) = (led(ny2+1:, 2)-y0d)*tan_theta + (le(ny2+1:, 2)-y0)*&
&       tan_thetad
      dx(ny2+1:) = (le(ny2+1:, 2)-y0)*tan_theta
    end if
    do ix=1,nx
      meshd(ix, :, 1) = meshd(ix, :, 1) + dxd
      mesh(ix, :, 1) = mesh(ix, :, 1) + dx
    end do
! x shear
    do ix=1,nx
      meshd(ix, :, 1) = meshd(ix, :, 1) + xsheard
      mesh(ix, :, 1) = mesh(ix, :, 1) + xshear
    end do
! span
    led = meshd(1, :, :)
    le = mesh(1, :, :)
    ted = meshd(nx, :, :)
    te = mesh(nx, :, :)
    quarter_chordd = 0.25*ted + 0.75*led
    quarter_chord = 0.25*te + 0.75*le
    new_spand = spand
    new_span = span
    if (symmetry) then
      new_spand = spand/2.
      new_span = span/2.
    end if
    sd = (quarter_chordd(:, 2)*(quarter_chord(ny, 2)-quarter_chord(1, 2)&
&     )-quarter_chord(:, 2)*(quarter_chordd(ny, 2)-quarter_chordd(1, 2))&
&     )/(quarter_chord(ny, 2)-quarter_chord(1, 2))**2
    s = quarter_chord(:, 2)/(quarter_chord(ny, 2)-quarter_chord(1, 2))
    do ix=1,nx
      meshd(ix, :, 2) = sd*new_span + s*new_spand
      mesh(ix, :, 2) = s*new_span
    end do
! y shear
    do ix=1,nx
      meshd(ix, :, 2) = meshd(ix, :, 2) + ysheard
      mesh(ix, :, 2) = mesh(ix, :, 2) + yshear
    end do
! dihedral
    led = meshd(1, :, :)
    le = mesh(1, :, :)
    tan_thetad = p180*dihedrald*(1.0+tan(p180*dihedral)**2)
    tan_theta = tan(p180*dihedral)
    if (symmetry) then
      y0d = led(ny, 2)
      y0 = le(ny, 2)
      dxd = -((led(:, 2)-y0d)*tan_theta+(le(:, 2)-y0)*tan_thetad)
      dx = -((le(:, 2)-y0)*tan_theta)
    else
      ny2 = (ny-1)/2
      y0d = led(ny2+1, 2)
      y0 = le(ny2+1, 2)
      dxd(:ny2) = -((led(:ny2, 2)-y0d)*tan_theta+(le(:ny2, 2)-y0)*&
&       tan_thetad)
      dx(:ny2) = -((le(:ny2, 2)-y0)*tan_theta)
      dxd(ny2+1:) = (led(ny2+1:, 2)-y0d)*tan_theta + (le(ny2+1:, 2)-y0)*&
&       tan_thetad
      dx(ny2+1:) = (le(ny2+1:, 2)-y0)*tan_theta
    end if
    do ix=1,nx
      meshd(ix, :, 3) = meshd(ix, :, 3) + dxd
      mesh(ix, :, 3) = mesh(ix, :, 3) + dx
    end do
! z shear
    do ix=1,nx
      meshd(ix, :, 3) = meshd(ix, :, 3) + zsheard
      mesh(ix, :, 3) = mesh(ix, :, 3) + zshear
    end do
! rotate
    led = meshd(1, :, :)
    le = mesh(1, :, :)
    ted = meshd(nx, :, :)
    te = mesh(nx, :, :)
    quarter_chordd = 0.25*ted + 0.75*led
    quarter_chord = 0.25*te + 0.75*le
    rad_theta_x(:) = 0.
    if (rotate_x) then
      if (symmetry) then
        dz_qcd = quarter_chordd(:ny-1, 3) - quarter_chordd(2:, 3)
        dz_qc = quarter_chord(:ny-1, 3) - quarter_chord(2:, 3)
        dy_qcd = quarter_chordd(:ny-1, 2) - quarter_chordd(2:, 2)
        dy_qc = quarter_chord(:ny-1, 2) - quarter_chord(2:, 2)
        rad_theta_xd = 0.0_8
        rad_theta_xd(:ny-1) = (dz_qcd*dy_qc-dz_qc*dy_qcd)/(dy_qc**2*(1.0&
&         +(dz_qc/dy_qc)**2))
        rad_theta_x(:ny-1) = atan(dz_qc/dy_qc)
      else
        ny2 = (ny-1)/2
        dz_qc_ld = quarter_chordd(:ny2, 3) - quarter_chordd(2:ny2+1, 3)
        dz_qc_l = quarter_chord(:ny2, 3) - quarter_chord(2:ny2+1, 3)
        dy_qc_ld = quarter_chordd(:ny2, 2) - quarter_chordd(2:ny2+1, 2)
        dy_qc_l = quarter_chord(:ny2, 2) - quarter_chord(2:ny2+1, 2)
        rad_theta_xd = 0.0_8
        rad_theta_xd(:ny2) = (dz_qc_ld*dy_qc_l-dz_qc_l*dy_qc_ld)/(&
&         dy_qc_l**2*(1.0+(dz_qc_l/dy_qc_l)**2))
        rad_theta_x(:ny2) = atan(dz_qc_l/dy_qc_l)
        dz_qc_rd = quarter_chordd(ny2+2:, 3) - quarter_chordd(ny2+1:ny-1&
&         , 3)
        dz_qc_r = quarter_chord(ny2+2:, 3) - quarter_chord(ny2+1:ny-1, 3&
&         )
        dy_qc_rd = quarter_chordd(ny2+2:, 2) - quarter_chordd(ny2+1:ny-1&
&         , 2)
        dy_qc_r = quarter_chord(ny2+2:, 2) - quarter_chord(ny2+1:ny-1, 2&
&         )
        rad_theta_xd(ny2+2:) = (dz_qc_rd*dy_qc_r-dz_qc_r*dy_qc_rd)/(&
&         dy_qc_r**2*(1.0+(dz_qc_r/dy_qc_r)**2))
        rad_theta_x(ny2+2:) = atan(dz_qc_r/dy_qc_r)
      end if
    else
      rad_theta_xd = 0.0_8
    end if
    rad_twistd = p180*twistd
    rad_twist = twist*p180
    rotation_matrix(:, :, :) = 0.
    rotation_matrixd = 0.0_8
    rotation_matrixd(:, 1, 1) = -(rad_twistd*sin(rad_twist))
    rotation_matrix(:, 1, 1) = cos(rad_twist)
    rotation_matrixd(:, 1, 3) = rad_twistd*cos(rad_twist)
    rotation_matrix(:, 1, 3) = sin(rad_twist)
    rotation_matrixd(:, 2, 1) = rad_theta_xd*cos(rad_theta_x)*sin(&
&     rad_twist) + sin(rad_theta_x)*rad_twistd*cos(rad_twist)
    rotation_matrix(:, 2, 1) = sin(rad_theta_x)*sin(rad_twist)
    rotation_matrixd(:, 2, 2) = -(rad_theta_xd*sin(rad_theta_x))
    rotation_matrix(:, 2, 2) = cos(rad_theta_x)
    rotation_matrixd(:, 2, 3) = -(rad_theta_xd*cos(rad_theta_x)*cos(&
&     rad_twist)-sin(rad_theta_x)*rad_twistd*sin(rad_twist))
    rotation_matrix(:, 2, 3) = -(sin(rad_theta_x)*cos(rad_twist))
    rotation_matrixd(:, 3, 1) = -(cos(rad_theta_x)*rad_twistd*cos(&
&     rad_twist)-rad_theta_xd*sin(rad_theta_x)*sin(rad_twist))
    rotation_matrix(:, 3, 1) = -(cos(rad_theta_x)*sin(rad_twist))
    rotation_matrixd(:, 3, 2) = rad_theta_xd*cos(rad_theta_x)
    rotation_matrix(:, 3, 2) = sin(rad_theta_x)
    rotation_matrixd(:, 3, 3) = -(rad_theta_xd*sin(rad_theta_x)*cos(&
&     rad_twist)) - cos(rad_theta_x)*rad_twistd*sin(rad_twist)
    rotation_matrix(:, 3, 3) = cos(rad_theta_x)*cos(rad_twist)
    do ix=1,nx
      rowd = meshd(ix, :, :)
      row = mesh(ix, :, :)
      do iy=1,ny
        call matmul2_d(3, 3, 1, rotation_matrix(iy, :, :), &
&                rotation_matrixd(iy, :, :), row(iy, :) - quarter_chord(&
&                iy, :), rowd(iy, :) - quarter_chordd(iy, :), out, outd)
        meshd(ix, iy, :) = outd
        mesh(ix, iy, :) = out
      end do
      meshd(ix, :, :) = meshd(ix, :, :) + quarter_chordd
      mesh(ix, :, :) = mesh(ix, :, :) + quarter_chord
    end do
  end subroutine manipulate_mesh_main_d
  subroutine manipulate_mesh_main(nx, ny, input_mesh, taper, chord, &
&   sweep, xshear, span, yshear, dihedral, zshear, twist, symmetry, &
&   rotate_x, mesh)
    implicit none
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: input_mesh(nx, ny, 3), taper, chord(ny)
    real(kind=8), intent(in) :: sweep, xshear(ny), span, yshear(ny)
    real(kind=8), intent(in) :: dihedral, zshear(ny), twist(ny)
    logical, intent(in) :: symmetry, rotate_x
    real(kind=8), intent(out) :: mesh(nx, ny, 3)
    real(kind=8) :: le(ny, 3), te(ny, 3), quarter_chord(ny, 3), p180, &
&   tan_theta
    real(kind=8) :: dx(ny), y0, rad_twist(ny), rotation_matrix(ny, 3, 3)
    real(kind=8) :: row(ny, 3), out(3), taper_lins(ny), taper_lins_sym((&
&   ny+1)/2)
    real(kind=8) :: rad_theta_x(ny), one, dz_qc(ny-1), dy_qc(ny-1), s(ny&
&   ), new_span
    real(kind=8) :: dz_qc_l((ny-1)/2), dz_qc_r((ny-1)/2), dy_qc_l((ny-1)&
&   /2), dy_qc_r((ny-1)/2)
    real(kind=8) :: computed_span
    integer :: ny2, ix, iy, ind
    intrinsic tan
    intrinsic atan
    intrinsic cos
    intrinsic sin
    p180 = 3.14159265358979323846264338/180.
    mesh = input_mesh
    one = 1.
! taper
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    quarter_chord = 0.25*te + 0.75*le
    if (symmetry) then
      computed_span = quarter_chord(ny, 2) - quarter_chord(1, 2)
      do iy=1,ny
        taper_lins(iy) = (quarter_chord(iy, 2)-quarter_chord(1, 2))/&
&         computed_span*(1-taper) + taper
      end do
      do iy=1,ny
        do ix=1,nx
          do ind=1,3
            mesh(ix, iy, ind) = (mesh(ix, iy, ind)-quarter_chord(iy, ind&
&             ))*taper_lins(iy) + quarter_chord(iy, ind)
          end do
        end do
      end do
    else
      computed_span = quarter_chord(ny, 2) - quarter_chord(1, 2)
      ny2 = (ny-1)/2
      do iy=1,ny2
        dx(iy) = 1 + quarter_chord(iy, 2)/(computed_span/2)*taper
      end do
      do iy=1,ny2
        dx(iy) = (quarter_chord(iy, 2)-quarter_chord(1, 2))/(&
&         computed_span/2)*(1-taper) + taper
      end do
      do iy=ny,ny2+1,-1
        dx(iy) = -((quarter_chord(iy, 2)-quarter_chord(ny, 2))/(&
&         computed_span/2)*(1-taper)) + taper
      end do
      do iy=1,ny
        do ix=1,nx
          do ind=1,3
            mesh(ix, iy, ind) = (mesh(ix, iy, ind)-quarter_chord(iy, ind&
&             ))*dx(iy) + quarter_chord(iy, ind)
          end do
        end do
      end do
    end if
! scale x
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    quarter_chord = 0.25*te + 0.75*le
    do iy=1,ny
      mesh(:, iy, 1) = (mesh(:, iy, 1)-quarter_chord(iy, 1))*chord(iy) +&
&       quarter_chord(iy, 1)
    end do
! sweep
    le = mesh(1, :, :)
    tan_theta = tan(p180*sweep)
    if (symmetry) then
      y0 = le(ny, 2)
      dx = -((le(:, 2)-y0)*tan_theta)
    else
      ny2 = (ny-1)/2
      y0 = le(ny2+1, 2)
      dx(:ny2) = -((le(:ny2, 2)-y0)*tan_theta)
      dx(ny2+1:) = (le(ny2+1:, 2)-y0)*tan_theta
    end if
    do ix=1,nx
      mesh(ix, :, 1) = mesh(ix, :, 1) + dx
    end do
! x shear
    do ix=1,nx
      mesh(ix, :, 1) = mesh(ix, :, 1) + xshear
    end do
! span
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    quarter_chord = 0.25*te + 0.75*le
    new_span = span
    if (symmetry) new_span = span/2.
    s = quarter_chord(:, 2)/(quarter_chord(ny, 2)-quarter_chord(1, 2))
    do ix=1,nx
      mesh(ix, :, 2) = s*new_span
    end do
! y shear
    do ix=1,nx
      mesh(ix, :, 2) = mesh(ix, :, 2) + yshear
    end do
! dihedral
    le = mesh(1, :, :)
    tan_theta = tan(p180*dihedral)
    if (symmetry) then
      y0 = le(ny, 2)
      dx = -((le(:, 2)-y0)*tan_theta)
    else
      ny2 = (ny-1)/2
      y0 = le(ny2+1, 2)
      dx(:ny2) = -((le(:ny2, 2)-y0)*tan_theta)
      dx(ny2+1:) = (le(ny2+1:, 2)-y0)*tan_theta
    end if
    do ix=1,nx
      mesh(ix, :, 3) = mesh(ix, :, 3) + dx
    end do
! z shear
    do ix=1,nx
      mesh(ix, :, 3) = mesh(ix, :, 3) + zshear
    end do
! rotate
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    quarter_chord = 0.25*te + 0.75*le
    rad_theta_x(:) = 0.
    if (rotate_x) then
      if (symmetry) then
        dz_qc = quarter_chord(:ny-1, 3) - quarter_chord(2:, 3)
        dy_qc = quarter_chord(:ny-1, 2) - quarter_chord(2:, 2)
        rad_theta_x(:ny-1) = atan(dz_qc/dy_qc)
      else
        ny2 = (ny-1)/2
        dz_qc_l = quarter_chord(:ny2, 3) - quarter_chord(2:ny2+1, 3)
        dy_qc_l = quarter_chord(:ny2, 2) - quarter_chord(2:ny2+1, 2)
        rad_theta_x(:ny2) = atan(dz_qc_l/dy_qc_l)
        dz_qc_r = quarter_chord(ny2+2:, 3) - quarter_chord(ny2+1:ny-1, 3&
&         )
        dy_qc_r = quarter_chord(ny2+2:, 2) - quarter_chord(ny2+1:ny-1, 2&
&         )
        rad_theta_x(ny2+2:) = atan(dz_qc_r/dy_qc_r)
      end if
    end if
    rad_twist = twist*p180
    rotation_matrix(:, :, :) = 0.
    rotation_matrix(:, 1, 1) = cos(rad_twist)
    rotation_matrix(:, 1, 3) = sin(rad_twist)
    rotation_matrix(:, 2, 1) = sin(rad_theta_x)*sin(rad_twist)
    rotation_matrix(:, 2, 2) = cos(rad_theta_x)
    rotation_matrix(:, 2, 3) = -(sin(rad_theta_x)*cos(rad_twist))
    rotation_matrix(:, 3, 1) = -(cos(rad_theta_x)*sin(rad_twist))
    rotation_matrix(:, 3, 2) = sin(rad_theta_x)
    rotation_matrix(:, 3, 3) = cos(rad_theta_x)*cos(rad_twist)
    do ix=1,nx
      row = mesh(ix, :, :)
      do iy=1,ny
        call matmul2(3, 3, 1, rotation_matrix(iy, :, :), row(iy, :) - &
&              quarter_chord(iy, :), out)
        mesh(ix, iy, :) = out
      end do
      mesh(ix, :, :) = mesh(ix, :, :) + quarter_chord
    end do
  end subroutine manipulate_mesh_main
  subroutine linspace(l, k, n, z)
    implicit none
!// argument declarations
    integer, intent(in) :: n
    real(kind=8), dimension(n), intent(out) :: z
    real(kind=8), intent(in) :: l
    real(kind=8), intent(in) :: k
!// local variables
    integer :: i
    real(kind=8) :: d
    d = (k-l)/(n-1)
    z(1) = l
    do i=2,n-1
      z(i) = z(i-1) + d
    end do
    z(1) = l
    z(n) = k
    return
  end subroutine linspace
!  differentiation of calc_vonmises_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: vonmises
!   with respect to varying inputs: r nodes disp
!   rw status of diff variables: r:in vonmises:out nodes:in disp:in
  subroutine calc_vonmises_main_d(nodes, nodesd, r, rd, disp, dispd, e, &
&   g, x_gl, n, vonmises, vonmisesd)
    implicit none
! input
    integer, intent(in) :: n
    real(kind=8), intent(in) :: nodes(n, 3), r(n-1), disp(n, 6)
    real(kind=8), intent(in) :: nodesd(n, 3), rd(n-1), dispd(n, 6)
    real(kind=8), intent(in) :: e, g, x_gl(3)
    real(kind=8) :: x_gld(3)
! output
    real(kind=8), intent(out) :: vonmises(n-1, 2)
    real(kind=8), intent(out) :: vonmisesd(n-1, 2)
! working
    integer :: ielem
    real(kind=8) :: p0(3), p1(3), l, x_loc(3), y_loc(3), z_loc(3), t(3, &
&   3)
    real(kind=8) :: p0d(3), p1d(3), ld, x_locd(3), y_locd(3), z_locd(3)&
&   , td(3, 3)
    real(kind=8) :: u0(3), r0(3), u1(3), r1(3), sxx0, sxx1, sxt, tmp
    real(kind=8) :: u0d(3), r0d(3), u1d(3), r1d(3), sxx0d, sxx1d, sxtd, &
&   tmpd
    real(kind=8) :: y_raw(3), z_raw(3), r1r0(3), t1(3), t2(3), t3(3), t4&
&   (3)
    real(kind=8) :: y_rawd(3), z_rawd(3), r1r0d(3), t1d(3), t2d(3), t3d(&
&   3), t4d(3)
    real(kind=8) :: nodes2(n, 3), r2(n-1), disp2(n, 6), p1p0(3)
    real(kind=8) :: nodes2d(n, 3), r2d(n-1), disp2d(n, 6), p1p0d(3)
    vonmises(:, :) = 0.
    nodes2d = nodesd
    nodes2 = nodes
    r2d = rd
    r2 = r
    disp2d = dispd
    disp2 = disp
    vonmisesd = 0.0_8
    y_locd = 0.0_8
    td = 0.0_8
    z_locd = 0.0_8
    y_rawd = 0.0_8
    z_rawd = 0.0_8
    x_locd = 0.0_8
    do ielem=1,n-1
      p0d = nodes2d(ielem, :)
      p0 = nodes2(ielem, :)
      p1d = nodes2d(ielem+1, :)
      p1 = nodes2(ielem+1, :)
      p1p0d = p1d - p0d
      p1p0 = p1 - p0
      call norm_d(p1p0, p1p0d, l, ld)
      call unit_d(p1p0, p1p0d, x_loc, x_locd)
      x_gld = 0.0_8
      call cross_d(x_loc, x_locd, x_gl, x_gld, y_raw, y_rawd)
      call unit_d(y_raw, y_rawd, y_loc, y_locd)
      call cross_d(x_loc, x_locd, y_loc, y_locd, z_raw, z_rawd)
      call unit_d(z_raw, z_rawd, z_loc, z_locd)
      td(1, :) = x_locd
      t(1, :) = x_loc
      td(2, :) = y_locd
      t(2, :) = y_loc
      td(3, :) = z_locd
      t(3, :) = z_loc
      t1d = disp2d(ielem, 1:3)
      t1 = disp2(ielem, 1:3)
      t2d = disp2d(ielem, 4:6)
      t2 = disp2(ielem, 4:6)
      t3d = disp2d(ielem+1, 1:3)
      t3 = disp2(ielem+1, 1:3)
      t4d = disp2d(ielem+1, 4:6)
      t4 = disp2(ielem+1, 4:6)
      call matmul2_d(3, 3, 1, t, td, t1, t1d, u0, u0d)
      call matmul2_d(3, 3, 1, t, td, t2, t2d, r0, r0d)
      call matmul2_d(3, 3, 1, t, td, t3, t3d, u1, u1d)
      call matmul2_d(3, 3, 1, t, td, t4, t4d, r1, r1d)
      r1r0d = r1d - r0d
      r1r0 = r1 - r0
      if (r1r0(2)**2 + r1r0(3)**2 .gt. 0.0_8) then
        tmpd = .5*(r1r0(2)**2+r1r0(3)**2)**(-0.5)*(2*r1r0(2)*r1r0d(2)+2*&
&         r1r0(3)*r1r0d(3))
      else
        tmpd = 0.0_8
      end if
      tmp = (r1r0(2)**2+r1r0(3)**2)**.5
      sxx0d = (e*(u1d(1)-u0d(1))*l-e*(u1(1)-u0(1))*ld)/l**2 + (e*r2d(&
&       ielem)*l-e*r2(ielem)*ld)*tmp/l**2 + e*r2(ielem)*tmpd/l
      sxx0 = e*(u1(1)-u0(1))/l + e*r2(ielem)/l*tmp
      sxx1d = (e*(u0d(1)-u1d(1))*l-e*(u0(1)-u1(1))*ld)/l**2 + (e*r2d(&
&       ielem)*l-e*r2(ielem)*ld)*tmp/l**2 + e*r2(ielem)*tmpd/l
      sxx1 = e*(u0(1)-u1(1))/l + e*r2(ielem)/l*tmp
      sxtd = (g*(r2d(ielem)*r1r0(1)+r2(ielem)*r1r0d(1))*l-g*r2(ielem)*&
&       r1r0(1)*ld)/l**2
      sxt = g*r2(ielem)*r1r0(1)/l
      if (sxx0**2 + 3*sxt**2 .gt. 0.0_8) then
        vonmisesd(ielem, 1) = .5*(sxx0**2+3*sxt**2)**(-0.5)*(2*sxx0*&
&         sxx0d+3*2*sxt*sxtd)
      else
        vonmisesd(ielem, 1) = 0.0_8
      end if
      vonmises(ielem, 1) = (sxx0**2+3*sxt**2)**.5
      if (sxx1**2 + 3*sxt**2 .gt. 0.0_8) then
        vonmisesd(ielem, 2) = .5*(sxx1**2+3*sxt**2)**(-0.5)*(2*sxx1*&
&         sxx1d+3*2*sxt*sxtd)
      else
        vonmisesd(ielem, 2) = 0.0_8
      end if
      vonmises(ielem, 2) = (sxx1**2+3*sxt**2)**.5
    end do
  end subroutine calc_vonmises_main_d
  subroutine calc_vonmises_main(nodes, r, disp, e, g, x_gl, n, vonmises)
    implicit none
! input
    integer, intent(in) :: n
    real(kind=8), intent(in) :: nodes(n, 3), r(n-1), disp(n, 6)
    real(kind=8), intent(in) :: e, g, x_gl(3)
! output
    real(kind=8), intent(out) :: vonmises(n-1, 2)
! working
    integer :: ielem
    real(kind=8) :: p0(3), p1(3), l, x_loc(3), y_loc(3), z_loc(3), t(3, &
&   3)
    real(kind=8) :: u0(3), r0(3), u1(3), r1(3), sxx0, sxx1, sxt, tmp
    real(kind=8) :: y_raw(3), z_raw(3), r1r0(3), t1(3), t2(3), t3(3), t4&
&   (3)
    real(kind=8) :: nodes2(n, 3), r2(n-1), disp2(n, 6), p1p0(3)
    vonmises(:, :) = 0.
    nodes2 = nodes
    r2 = r
    disp2 = disp
    do ielem=1,n-1
      p0 = nodes2(ielem, :)
      p1 = nodes2(ielem+1, :)
      p1p0 = p1 - p0
      call norm(p1p0, l)
      call unit(p1p0, x_loc)
      call cross(x_loc, x_gl, y_raw)
      call unit(y_raw, y_loc)
      call cross(x_loc, y_loc, z_raw)
      call unit(z_raw, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      t1 = disp2(ielem, 1:3)
      t2 = disp2(ielem, 4:6)
      t3 = disp2(ielem+1, 1:3)
      t4 = disp2(ielem+1, 4:6)
      call matmul2(3, 3, 1, t, t1, u0)
      call matmul2(3, 3, 1, t, t2, r0)
      call matmul2(3, 3, 1, t, t3, u1)
      call matmul2(3, 3, 1, t, t4, r1)
      r1r0 = r1 - r0
      tmp = (r1r0(2)**2+r1r0(3)**2)**.5
      sxx0 = e*(u1(1)-u0(1))/l + e*r2(ielem)/l*tmp
      sxx1 = e*(u0(1)-u1(1))/l + e*r2(ielem)/l*tmp
      sxt = g*r2(ielem)*r1r0(1)/l
      vonmises(ielem, 1) = (sxx0**2+3*sxt**2)**.5
      vonmises(ielem, 2) = (sxx1**2+3*sxt**2)**.5
    end do
  end subroutine calc_vonmises_main
!  differentiation of transferdisplacements_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: def_mesh
!   with respect to varying inputs: mesh disp
!   rw status of diff variables: mesh:in def_mesh:out disp:in
  subroutine transferdisplacements_main_d(nx, ny, mesh, meshd, disp, &
&   dispd, w, def_mesh, def_meshd)
    implicit none
! input
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: mesh(nx, ny, 3), disp(ny, 6), w
    real(kind=8), intent(in) :: meshd(nx, ny, 3), dispd(ny, 6)
! output
    real(kind=8), intent(out) :: def_mesh(nx, ny, 3)
    real(kind=8), intent(out) :: def_meshd(nx, ny, 3)
! working
    integer :: ind, indx
    real(kind=8) :: smesh(nx, ny, 3), t(3, 3), t_base(3, 3), vec(3)
    real(kind=8) :: smeshd(nx, ny, 3), td(3, 3), vecd(3)
    real(kind=8) :: sinr(3), cosr(3), r(3), ref_curve(ny, 3)
    real(kind=8) :: sinrd(3), cosrd(3), rd(3), ref_curved(ny, 3)
    intrinsic cos
    intrinsic sin
    ref_curved = (1-w)*meshd(1, :, :) + w*meshd(nx, :, :)
    ref_curve = (1-w)*mesh(1, :, :) + w*mesh(nx, :, :)
    def_mesh(:, :, :) = 0.
    t_base(:, :) = 0.
    do ind=1,3
      t_base(ind, ind) = -2.
    end do
    smeshd = 0.0_8
    do ind=1,nx
      smeshd(ind, :, :) = meshd(ind, :, :) - ref_curved
      smesh(ind, :, :) = mesh(ind, :, :) - ref_curve
    end do
    def_meshd = 0.0_8
    do ind=1,ny
      rd = dispd(ind, 4:6)
      r = disp(ind, 4:6)
      cosrd = -(rd*sin(r))
      cosr = cos(r)
      sinrd = rd*cos(r)
      sinr = sin(r)
      t(:, :) = 0.
      td = 0.0_8
      td(1, 1) = cosrd(3) + cosrd(2)
      t(1, 1) = cosr(3) + cosr(2)
      td(2, 2) = cosrd(3) + cosrd(1)
      t(2, 2) = cosr(3) + cosr(1)
      td(3, 3) = cosrd(1) + cosrd(2)
      t(3, 3) = cosr(1) + cosr(2)
      td(1, 2) = -sinrd(3)
      t(1, 2) = -sinr(3)
      td(1, 3) = sinrd(2)
      t(1, 3) = sinr(2)
      td(2, 1) = sinrd(3)
      t(2, 1) = sinr(3)
      td(2, 3) = -sinrd(1)
      t(2, 3) = -sinr(1)
      td(3, 1) = -sinrd(2)
      t(3, 1) = -sinr(2)
      td(3, 2) = sinrd(1)
      t(3, 2) = sinr(1)
      t = t + t_base
      do indx=1,nx
        call matmul2_d(3, 3, 1, t, td, smesh(indx, ind, :), smeshd(indx&
&                , ind, :), vec, vecd)
        def_meshd(indx, ind, :) = def_meshd(indx, ind, :) + vecd
        def_mesh(indx, ind, :) = def_mesh(indx, ind, :) + vec
      end do
      def_meshd(:, ind, 1) = def_meshd(:, ind, 1) + dispd(ind, 1)
      def_mesh(:, ind, 1) = def_mesh(:, ind, 1) + disp(ind, 1)
      def_meshd(:, ind, 2) = def_meshd(:, ind, 2) + dispd(ind, 2)
      def_mesh(:, ind, 2) = def_mesh(:, ind, 2) + disp(ind, 2)
      def_meshd(:, ind, 3) = def_meshd(:, ind, 3) + dispd(ind, 3)
      def_mesh(:, ind, 3) = def_mesh(:, ind, 3) + disp(ind, 3)
    end do
    def_meshd = def_meshd + meshd
    def_mesh = def_mesh + mesh
  end subroutine transferdisplacements_main_d
  subroutine transferdisplacements_main(nx, ny, mesh, disp, w, def_mesh)
    implicit none
! input
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: mesh(nx, ny, 3), disp(ny, 6), w
! output
    real(kind=8), intent(out) :: def_mesh(nx, ny, 3)
! working
    integer :: ind, indx
    real(kind=8) :: smesh(nx, ny, 3), t(3, 3), t_base(3, 3), vec(3)
    real(kind=8) :: sinr(3), cosr(3), r(3), ref_curve(ny, 3)
    intrinsic cos
    intrinsic sin
    ref_curve = (1-w)*mesh(1, :, :) + w*mesh(nx, :, :)
    def_mesh(:, :, :) = 0.
    t_base(:, :) = 0.
    do ind=1,3
      t_base(ind, ind) = -2.
    end do
    do ind=1,nx
      smesh(ind, :, :) = mesh(ind, :, :) - ref_curve
    end do
    do ind=1,ny
      r = disp(ind, 4:6)
      cosr = cos(r)
      sinr = sin(r)
      t(:, :) = 0.
      t(1, 1) = cosr(3) + cosr(2)
      t(2, 2) = cosr(3) + cosr(1)
      t(3, 3) = cosr(1) + cosr(2)
      t(1, 2) = -sinr(3)
      t(1, 3) = sinr(2)
      t(2, 1) = sinr(3)
      t(2, 3) = -sinr(1)
      t(3, 1) = -sinr(2)
      t(3, 2) = sinr(1)
      t = t + t_base
      do indx=1,nx
        call matmul2(3, 3, 1, t, smesh(indx, ind, :), vec)
        def_mesh(indx, ind, :) = def_mesh(indx, ind, :) + vec
      end do
      def_mesh(:, ind, 1) = def_mesh(:, ind, 1) + disp(ind, 1)
      def_mesh(:, ind, 2) = def_mesh(:, ind, 2) + disp(ind, 2)
      def_mesh(:, ind, 3) = def_mesh(:, ind, 3) + disp(ind, 3)
    end do
    def_mesh = def_mesh + mesh
  end subroutine transferdisplacements_main
!  differentiation of transferloads_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: loads
!   with respect to varying inputs: sec_forces def_mesh
!   rw status of diff variables: loads:out sec_forces:in def_mesh:in
  subroutine transferloads_main_d(nx, ny, def_mesh, def_meshd, &
&   sec_forces, sec_forcesd, fem_origin, loads, loadsd)
    implicit none
! input
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: def_mesh(nx, ny, 3), sec_forces(nx-1, ny&
&   -1, 3), fem_origin
    real(kind=8), intent(in) :: def_meshd(nx, ny, 3), sec_forcesd(nx-1, &
&   ny-1, 3)
! output
    real(kind=8), intent(out) :: loads(ny, 6)
    real(kind=8), intent(out) :: loadsd(ny, 6)
! working
    integer :: ind, indy
    real(kind=8) :: w, moment(ny-1, 3), a_pts(nx-1, ny-1, 3), s_pts(ny-1&
&   , 3)
    real(kind=8) :: momentd(ny-1, 3), a_ptsd(nx-1, ny-1, 3), s_ptsd(ny-1&
&   , 3)
    real(kind=8) :: diff(3), tmp(3), sec_forces_sum(ny-1, 3)
    real(kind=8) :: diffd(3), tmpd(3), sec_forces_sumd(ny-1, 3)
! compute the aerodynamic centers at the quarter-chord point of each panel
    w = 0.25
    a_ptsd = 0.5*(1-w)*def_meshd(:nx-1, :ny-1, :) + 0.5*w*def_meshd(2:, &
&     :ny-1, :) + 0.5*(1-w)*def_meshd(:nx-1, 2:, :) + 0.5*w*def_meshd(2:&
&     , 2:, :)
    a_pts = 0.5*(1-w)*def_mesh(:nx-1, :ny-1, :) + 0.5*w*def_mesh(2:, :ny&
&     -1, :) + 0.5*(1-w)*def_mesh(:nx-1, 2:, :) + 0.5*w*def_mesh(2:, 2:&
&     , :)
! compute the structural midpoints based on the fem_origin location
    w = fem_origin
    s_ptsd = 0.5*(1-w)*def_meshd(1, :ny-1, :) + 0.5*w*def_meshd(nx, :ny-&
&     1, :) + 0.5*(1-w)*def_meshd(1, 2:, :) + 0.5*w*def_meshd(nx, 2:, :)
    s_pts = 0.5*(1-w)*def_mesh(1, :ny-1, :) + 0.5*w*def_mesh(nx, :ny-1, &
&     :) + 0.5*(1-w)*def_mesh(1, 2:, :) + 0.5*w*def_mesh(nx, 2:, :)
! find the moment arm between the aerodynamic centers of each panel
! and the fem elements
    moment = 0.
    momentd = 0.0_8
    do ind=1,nx-1
      do indy=1,ny-1
        diffd = a_ptsd(ind, indy, :) - s_ptsd(indy, :)
        diff = a_pts(ind, indy, :) - s_pts(indy, :)
        tmp = 0.
        tmpd = 0.0_8
        call cross_d(diff, diffd, sec_forces(ind, indy, :), sec_forcesd(&
&              ind, indy, :), tmp, tmpd)
        momentd(indy, :) = momentd(indy, :) + tmpd
        moment(indy, :) = moment(indy, :) + tmp
      end do
    end do
! compute the loads based on the xyz forces and the computed moments
    sec_forces_sum = 0.
    sec_forces_sumd = 0.0_8
    do ind=1,nx-1
      sec_forces_sumd = sec_forces_sumd + sec_forcesd(ind, :, :)
      sec_forces_sum = sec_forces_sum + sec_forces(ind, :, :)
    end do
    loads = 0.
    loadsd = 0.0_8
    loadsd(:ny-1, :3) = 0.5*sec_forces_sumd
    loads(:ny-1, :3) = loads(:ny-1, :3) + 0.5*sec_forces_sum
    loadsd(2:, :3) = loadsd(2:, :3) + 0.5*sec_forces_sumd
    loads(2:, :3) = loads(2:, :3) + 0.5*sec_forces_sum
    loadsd(:ny-1, 4:) = loadsd(:ny-1, 4:) + 0.5*momentd
    loads(:ny-1, 4:) = loads(:ny-1, 4:) + 0.5*moment
    loadsd(2:, 4:) = loadsd(2:, 4:) + 0.5*momentd
    loads(2:, 4:) = loads(2:, 4:) + 0.5*moment
  end subroutine transferloads_main_d
  subroutine transferloads_main(nx, ny, def_mesh, sec_forces, fem_origin&
&   , loads)
    implicit none
! input
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: def_mesh(nx, ny, 3), sec_forces(nx-1, ny&
&   -1, 3), fem_origin
! output
    real(kind=8), intent(out) :: loads(ny, 6)
! working
    integer :: ind, indy
    real(kind=8) :: w, moment(ny-1, 3), a_pts(nx-1, ny-1, 3), s_pts(ny-1&
&   , 3)
    real(kind=8) :: diff(3), tmp(3), sec_forces_sum(ny-1, 3)
! compute the aerodynamic centers at the quarter-chord point of each panel
    w = 0.25
    a_pts = 0.5*(1-w)*def_mesh(:nx-1, :ny-1, :) + 0.5*w*def_mesh(2:, :ny&
&     -1, :) + 0.5*(1-w)*def_mesh(:nx-1, 2:, :) + 0.5*w*def_mesh(2:, 2:&
&     , :)
! compute the structural midpoints based on the fem_origin location
    w = fem_origin
    s_pts = 0.5*(1-w)*def_mesh(1, :ny-1, :) + 0.5*w*def_mesh(nx, :ny-1, &
&     :) + 0.5*(1-w)*def_mesh(1, 2:, :) + 0.5*w*def_mesh(nx, 2:, :)
! find the moment arm between the aerodynamic centers of each panel
! and the fem elements
    moment = 0.
    do ind=1,nx-1
      do indy=1,ny-1
        diff = a_pts(ind, indy, :) - s_pts(indy, :)
        tmp = 0.
        call cross(diff, sec_forces(ind, indy, :), tmp)
        moment(indy, :) = moment(indy, :) + tmp
      end do
    end do
! compute the loads based on the xyz forces and the computed moments
    sec_forces_sum = 0.
    do ind=1,nx-1
      sec_forces_sum = sec_forces_sum + sec_forces(ind, :, :)
    end do
    loads = 0.
    loads(:ny-1, :3) = loads(:ny-1, :3) + 0.5*sec_forces_sum
    loads(2:, :3) = loads(2:, :3) + 0.5*sec_forces_sum
    loads(:ny-1, 4:) = loads(:ny-1, 4:) + 0.5*moment
    loads(2:, 4:) = loads(2:, 4:) + 0.5*moment
  end subroutine transferloads_main
!  differentiation of assemblestructmtx_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: k
!   with respect to varying inputs: j nodes iy iz a
!   rw status of diff variables: j:in k:out nodes:in iy:in iz:in
!                a:in
  subroutine assemblestructmtx_main_d(n, tot_n_fem, nodes, nodesd, a, ad&
&   , j, jd, iy, iyd, iz, izd, k_a, k_t, k_y, k_z, cons, e, g, x_gl, t, &
&   k_elem, pelem_a, pelem_t, pelem_y, pelem_z, t_elem, const2, const_y&
&   , const_z, k, kd)
    implicit none
! input
    integer, intent(in) :: n, cons, tot_n_fem
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    real(kind=8), intent(in) :: nodesd(tot_n_fem, 3), ad(n-1), jd(n-1), &
&   iyd(n-1), izd(n-1)
    real(kind=8), intent(in) :: e, g, x_gl(3)
    real(kind=8) :: x_gld(3)
    real(kind=8), intent(inout) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    real(kind=8) :: k_ad(2, 2)
    real(kind=8), intent(inout) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    real(kind=8) :: td(3, 3)
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    real(kind=8) :: pelem_ad(2, 12)
    real(kind=8), intent(in) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4)
! output
    real(kind=8), intent(out) :: k(6*n+6, 6*n+6)
    real(kind=8), intent(out) :: kd(6*n+6, 6*n+6)
! working
    real(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    real(kind=8) :: p0d(3), p1d(3), x_locd(3), y_locd(3), z_locd(3), &
&   x_crossd(3), y_crossd(3)
    real(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    real(kind=8) :: ld, ea_ld, gj_ld, eiy_l3d, eiz_l3d, resd(12, 12)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    real(kind=8) :: mat12x12d(12, 12), mat12x4d(12, 4), mat12x2d(12, 2)
    integer :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(6*n+6, 6*n+6)
    real(kind=8) :: pelem_a_td(12, 2), pelem_t_td(12, 2)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)
    real(kind=8) :: pelem_y_td(12, 4), pelem_z_td(12, 4), t_elem_td(12, &
&   12)
    real(kind=8) :: pelem_zd(4, 12)
    real(kind=8) :: k_elemd(12, 12)
    real(kind=8) :: k_yd(4, 4)
    real(kind=8) :: pelem_yd(4, 12)
    real(kind=8) :: t_elemd(12, 12)
    real(kind=8) :: k_td(2, 2)
    real(kind=8) :: k_zd(4, 4)
    real(kind=8) :: pelem_td(2, 12)
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    num_cons = 1
    k(:, :) = 0.
    kd = 0.0_8
    td = 0.0_8
    t_elemd = 0.0_8
    y_locd = 0.0_8
    z_locd = 0.0_8
    t_elem_td = 0.0_8
    y_crossd = 0.0_8
    x_crossd = 0.0_8
    x_locd = 0.0_8
! loop over num elements
    do ielem=1,num_elems
      p0d = nodesd(ielem, :)
      p0 = nodes(ielem, :)
      p1d = nodesd(ielem+1, :)
      p1 = nodes(ielem+1, :)
      call unit_d(p1 - p0, p1d - p0d, x_loc, x_locd)
      x_gld = 0.0_8
      call cross_d(x_loc, x_locd, x_gl, x_gld, x_cross, x_crossd)
      call unit_d(x_cross, x_crossd, y_loc, y_locd)
      call cross_d(x_loc, x_locd, y_loc, y_locd, y_cross, y_crossd)
      call unit_d(y_cross, y_crossd, z_loc, z_locd)
      td(1, :) = x_locd
      t(1, :) = x_loc
      td(2, :) = y_locd
      t(2, :) = y_loc
      td(3, :) = z_locd
      t(3, :) = z_loc
      do ind=1,4
        t_elemd(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = td
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      end do
      call norm_d(p1 - p0, p1d - p0d, l, ld)
      ea_ld = (e*ad(ielem)*l-e*a(ielem)*ld)/l**2
      ea_l = e*a(ielem)/l
      gj_ld = (g*jd(ielem)*l-g*j(ielem)*ld)/l**2
      gj_l = g*j(ielem)/l
      eiy_l3d = (e*iyd(ielem)*l**3-e*iy(ielem)*3*l**2*ld)/(l**3)**2
      eiy_l3 = e*iy(ielem)/l**3
      eiz_l3d = (e*izd(ielem)*l**3-e*iz(ielem)*3*l**2*ld)/(l**3)**2
      eiz_l3 = e*iz(ielem)/l**3
      k_ad(:, :) = const2*ea_ld
      k_a(:, :) = ea_l*const2
      k_td(:, :) = const2*gj_ld
      k_t(:, :) = gj_l*const2
      k_yd(:, :) = const_y*eiy_l3d
      k_y(:, :) = eiy_l3*const_y
      k_yd(2, :) = k_yd(2, :)*l + k_y(2, :)*ld
      k_y(2, :) = k_y(2, :)*l
      k_yd(4, :) = k_yd(4, :)*l + k_y(4, :)*ld
      k_y(4, :) = k_y(4, :)*l
      k_yd(:, 2) = k_yd(:, 2)*l + k_y(:, 2)*ld
      k_y(:, 2) = k_y(:, 2)*l
      k_yd(:, 4) = k_yd(:, 4)*l + k_y(:, 4)*ld
      k_y(:, 4) = k_y(:, 4)*l
      k_zd(:, :) = const_z*eiz_l3d
      k_z(:, :) = eiz_l3*const_z
      k_zd(2, :) = k_zd(2, :)*l + k_z(2, :)*ld
      k_z(2, :) = k_z(2, :)*l
      k_zd(4, :) = k_zd(4, :)*l + k_z(4, :)*ld
      k_z(4, :) = k_z(4, :)*l
      k_zd(:, 2) = k_zd(:, 2)*l + k_z(:, 2)*ld
      k_z(:, 2) = k_z(:, 2)*l
      k_zd(:, 4) = k_zd(:, 4)*l + k_z(:, 4)*ld
      k_z(:, 4) = k_z(:, 4)*l
      k_elem(:, :) = 0.
      call transpose2(2, 12, pelem_a, pelem_a_t)
      pelem_a_td = 0.0_8
      call matmul2_d(12, 2, 2, pelem_a_t, pelem_a_td, k_a, k_ad, mat12x2&
&              , mat12x2d)
      pelem_ad = 0.0_8
      call matmul2_d(12, 2, 12, mat12x2, mat12x2d, pelem_a, pelem_ad, &
&              res, resd)
      k_elemd = resd
      k_elem = k_elem + res
      call transpose2(2, 12, pelem_t, pelem_t_t)
      pelem_t_td = 0.0_8
      call matmul2_d(12, 2, 2, pelem_t_t, pelem_t_td, k_t, k_td, mat12x2&
&              , mat12x2d)
      pelem_td = 0.0_8
      call matmul2_d(12, 2, 12, mat12x2, mat12x2d, pelem_t, pelem_td, &
&              res, resd)
      k_elemd = k_elemd + resd
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_y, pelem_y_t)
      pelem_y_td = 0.0_8
      call matmul2_d(12, 4, 4, pelem_y_t, pelem_y_td, k_y, k_yd, mat12x4&
&              , mat12x4d)
      pelem_yd = 0.0_8
      call matmul2_d(12, 4, 12, mat12x4, mat12x4d, pelem_y, pelem_yd, &
&              res, resd)
      k_elemd = k_elemd + resd
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_z, pelem_z_t)
      pelem_z_td = 0.0_8
      call matmul2_d(12, 4, 4, pelem_z_t, pelem_z_td, k_z, k_zd, mat12x4&
&              , mat12x4d)
      pelem_zd = 0.0_8
      call matmul2_d(12, 4, 12, mat12x4, mat12x4d, pelem_z, pelem_zd, &
&              res, resd)
      k_elemd = k_elemd + resd
      k_elem = k_elem + res
      call transpose2_d(12, 12, t_elem, t_elemd, t_elem_t, t_elem_td)
      call matmul2_d(12, 12, 12, t_elem_t, t_elem_td, k_elem, k_elemd, &
&              mat12x12, mat12x12d)
      call matmul2_d(12, 12, 12, mat12x12, mat12x12d, t_elem, t_elemd, &
&              res, resd)
      in0 = ielem
      in1 = ielem + 1
      kd(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = kd(6*(in0-1&
&       )+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + resd(:6, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      kd(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = kd(6*(in1-1&
&       )+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + resd(7:, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      kd(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = kd(6*(in0-1&
&       )+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + resd(:6, 7:)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      kd(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = kd(6*(in1-1&
&       )+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + resd(7:, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    end do
    do i=1,6
      kd(6*num_nodes+i, 6*cons+i) = 0.0_8
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      kd(6*cons+i, 6*num_nodes+i) = 0.0_8
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    end do
  end subroutine assemblestructmtx_main_d
  subroutine assemblestructmtx_main(n, tot_n_fem, nodes, a, j, iy, iz, &
&   k_a, k_t, k_y, k_z, cons, e, g, x_gl, t, k_elem, pelem_a, pelem_t, &
&   pelem_y, pelem_z, t_elem, const2, const_y, const_z, k)
    implicit none
! input
    integer, intent(in) :: n, cons, tot_n_fem
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    real(kind=8), intent(in) :: e, g, x_gl(3)
    real(kind=8), intent(inout) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    real(kind=8), intent(inout) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    real(kind=8), intent(in) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4)
! output
    real(kind=8), intent(out) :: k(6*n+6, 6*n+6)
! working
    real(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    real(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    integer :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(6*n+6, 6*n+6)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    num_cons = 1
    k(:, :) = 0.
! loop over num elements
    do ielem=1,num_elems
      p0 = nodes(ielem, :)
      p1 = nodes(ielem+1, :)
      call unit(p1 - p0, x_loc)
      call cross(x_loc, x_gl, x_cross)
      call unit(x_cross, y_loc)
      call cross(x_loc, y_loc, y_cross)
      call unit(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      do ind=1,4
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      end do
      call norm(p1 - p0, l)
      ea_l = e*a(ielem)/l
      gj_l = g*j(ielem)/l
      eiy_l3 = e*iy(ielem)/l**3
      eiz_l3 = e*iz(ielem)/l**3
      k_a(:, :) = ea_l*const2
      k_t(:, :) = gj_l*const2
      k_y(:, :) = eiy_l3*const_y
      k_y(2, :) = k_y(2, :)*l
      k_y(4, :) = k_y(4, :)*l
      k_y(:, 2) = k_y(:, 2)*l
      k_y(:, 4) = k_y(:, 4)*l
      k_z(:, :) = eiz_l3*const_z
      k_z(2, :) = k_z(2, :)*l
      k_z(4, :) = k_z(4, :)*l
      k_z(:, 2) = k_z(:, 2)*l
      k_z(:, 4) = k_z(:, 4)*l
      k_elem(:, :) = 0.
      call transpose2(2, 12, pelem_a, pelem_a_t)
      call matmul2(12, 2, 2, pelem_a_t, k_a, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      call transpose2(2, 12, pelem_t, pelem_t_t)
      call matmul2(12, 2, 2, pelem_t_t, k_t, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_y, pelem_y_t)
      call matmul2(12, 4, 4, pelem_y_t, k_y, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_z, pelem_z_t)
      call matmul2(12, 4, 4, pelem_z_t, k_z, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      call transpose2(12, 12, t_elem, t_elem_t)
      call matmul2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      call matmul2(12, 12, 12, mat12x12, t_elem, res)
      in0 = ielem
      in1 = ielem + 1
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    end do
    do i=1,6
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    end do
  end subroutine assemblestructmtx_main
!  differentiation of transpose2 in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: new_mtx
!   with respect to varying inputs: new_mtx mtx
  subroutine transpose2_d(m, n, mtx, mtxd, new_mtx, new_mtxd)
    implicit none
    integer, intent(in) :: m, n
    real(kind=8), intent(in) :: mtx(m, n)
    real(kind=8), intent(in) :: mtxd(m, n)
    real(kind=8), intent(out) :: new_mtx(n, m)
    real(kind=8), intent(out) :: new_mtxd(n, m)
    integer :: i, j
    do i=1,m
      do j=1,n
        new_mtxd(j, i) = mtxd(i, j)
        new_mtx(j, i) = mtx(i, j)
      end do
    end do
  end subroutine transpose2_d
  subroutine transpose2(m, n, mtx, new_mtx)
    implicit none
    integer, intent(in) :: m, n
    real(kind=8), intent(in) :: mtx(m, n)
    real(kind=8), intent(out) :: new_mtx(n, m)
    integer :: i, j
    do i=1,m
      do j=1,n
        new_mtx(j, i) = mtx(i, j)
      end do
    end do
  end subroutine transpose2
!  differentiation of matmul2 in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: c
!   with respect to varying inputs: a b
  subroutine matmul2_d(m, n, p, a, ad, b, bd, c, cd)
    implicit none
    integer, intent(in) :: m, n, p
    real(kind=8), intent(in) :: a(m, n), b(n, p)
    real(kind=8), intent(in) :: ad(m, n), bd(n, p)
    real(kind=8), intent(out) :: c(m, p)
    real(kind=8), intent(out) :: cd(m, p)
    integer :: i, j, k
    c(:, :) = 0.
    cd = 0.0_8
    do i=1,m
      do j=1,p
        do k=1,n
          cd(i, j) = cd(i, j) + ad(i, k)*b(k, j) + a(i, k)*bd(k, j)
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        end do
      end do
    end do
  end subroutine matmul2_d
  subroutine matmul2(m, n, p, a, b, c)
    implicit none
    integer, intent(in) :: m, n, p
    real(kind=8), intent(in) :: a(m, n), b(n, p)
    real(kind=8), intent(out) :: c(m, p)
    integer :: i, j, k
    c(:, :) = 0.
    do i=1,m
      do j=1,p
        do k=1,n
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        end do
      end do
    end do
  end subroutine matmul2
!  differentiation of assembleaeromtx_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: mtx
!   with respect to varying inputs: alpha points mesh bpts
!   rw status of diff variables: alpha:in points:in mesh:in bpts:in
!                mtx:out
  subroutine assembleaeromtx_main_d(ny, nx, ny_, nx_, alpha, alphad, &
&   points, pointsd, bpts, bptsd, mesh, meshd, skip, symmetry, mtx, mtxd&
& )
    implicit none
! input
    integer, intent(in) :: ny, nx, ny_, nx_
    real(kind=8), intent(in) :: alpha, mesh(nx_, ny_, 3)
    real(kind=8), intent(in) :: alphad, meshd(nx_, ny_, 3)
    real(kind=8), intent(in) :: points(nx-1, ny-1, 3), bpts(nx_-1, ny_, &
&   3)
    real(kind=8), intent(in) :: pointsd(nx-1, ny-1, 3), bptsd(nx_-1, ny_&
&   , 3)
    logical, intent(in) :: skip, symmetry
! output
    real(kind=8), intent(out) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
    real(kind=8), intent(out) :: mtxd((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
! working
    integer :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    real(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    real(kind=8) :: pd(3), ad(3), bd(3), ud(3), cd(3), dd(3)
    real(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    real(kind=8) :: a_symd(3), b_symd(3), c_symd(3), d_symd(3)
    real(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    real(kind=8) :: ur2d(3), r1d(3), r2d(3), r1_magd, r2_magd
    real(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    real(kind=8) :: ur1d(3), boundd(3), dot_ur2d, dot_ur1d
    real(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym(3)
    real(kind=8) :: edgesd(3), c_ted(3), d_ted(3), c_te_symd(3), &
&   d_te_symd(3)
    intrinsic atan
    intrinsic cos
    intrinsic sin
    pi = 4.d0*atan(1.d0)
! trailing vortices in avl follow the x-axis; no cos or sin
! u(1) = 1.
! u(3) = 0.
    ud = 0.0_8
    ud(1) = -(pi*alphad*sin(alpha*pi/180.)/180.)
    u(1) = cos(alpha*pi/180.)
    ud(2) = 0.0_8
    u(2) = 0.
    ud(3) = pi*alphad*cos(alpha*pi/180.)/180.
    u(3) = sin(alpha*pi/180.)
    mtx(:, :, :) = 0.
    mtxd = 0.0_8
    ur1d = 0.0_8
    ur2d = 0.0_8
    c_te_symd = 0.0_8
    d_te_symd = 0.0_8
! spanwise loop through horseshoe elements
    do el_j=1,ny_-1
      el_loc_j = (el_j-1)*(nx_-1)
      c_ted = meshd(nx_, el_j+1, :)
      c_te = mesh(nx_, el_j+1, :)
      d_ted = meshd(nx_, el_j+0, :)
      d_te = mesh(nx_, el_j+0, :)
      if (symmetry) then
        c_te_symd = c_ted
        c_te_sym = c_te
        d_te_symd = d_ted
        d_te_sym = d_te
        c_te_symd(2) = -c_te_symd(2)
        c_te_sym(2) = -c_te_sym(2)
        d_te_symd(2) = -d_te_symd(2)
        d_te_sym(2) = -d_te_sym(2)
      end if
! spanwise loop through control points
      do cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        do cp_i=1,nx-1
          cp_loc = cp_i + cp_loc_j
          pd = pointsd(cp_i, cp_j, :)
          p = points(cp_i, cp_j, :)
          r1d = pd - d_ted
          r1 = p - d_te
          r2d = pd - c_ted
          r2 = p - c_te
          call norm_d(r1, r1d, r1_mag, r1_magd)
          call norm_d(r2, r2d, r2_mag, r2_magd)
          call cross_d(u, ud, r2, r2d, ur2, ur2d)
          call cross_d(u, ud, r1, r1d, ur1, ur1d)
          edges(:) = 0.
          call dot_d(u, ud, r2, r2d, dot_ur2, dot_ur2d)
          call dot_d(u, ud, r1, r1d, dot_ur1, dot_ur1d)
          edgesd = (ur2d*r2_mag*(r2_mag-dot_ur2)-ur2*(r2_magd*(r2_mag-&
&           dot_ur2)+r2_mag*(r2_magd-dot_ur2d)))/(r2_mag*(r2_mag-dot_ur2&
&           ))**2
          edges = ur2/(r2_mag*(r2_mag-dot_ur2))
          edgesd = edgesd - (ur1d*r1_mag*(r1_mag-dot_ur1)-ur1*(r1_magd*(&
&           r1_mag-dot_ur1)+r1_mag*(r1_magd-dot_ur1d)))/(r1_mag*(r1_mag-&
&           dot_ur1))**2
          edges = edges - ur1/(r1_mag*(r1_mag-dot_ur1))
          if (symmetry) then
            r1d = pd - d_te_symd
            r1 = p - d_te_sym
            r2d = pd - c_te_symd
            r2 = p - c_te_sym
            call norm_d(r1, r1d, r1_mag, r1_magd)
            call norm_d(r2, r2d, r2_mag, r2_magd)
            call cross_d(u, ud, r2, r2d, ur2, ur2d)
            call cross_d(u, ud, r1, r1d, ur1, ur1d)
            call dot_d(u, ud, r2, r2d, dot_ur2, dot_ur2d)
            call dot_d(u, ud, r1, r1d, dot_ur1, dot_ur1d)
            edgesd = edgesd - (ur2d*r2_mag*(r2_mag-dot_ur2)-ur2*(r2_magd&
&             *(r2_mag-dot_ur2)+r2_mag*(r2_magd-dot_ur2d)))/(r2_mag*(&
&             r2_mag-dot_ur2))**2
            edges = edges - ur2/(r2_mag*(r2_mag-dot_ur2))
            edgesd = edgesd + (ur1d*r1_mag*(r1_mag-dot_ur1)-ur1*(r1_magd&
&             *(r1_mag-dot_ur1)+r1_mag*(r1_magd-dot_ur1d)))/(r1_mag*(&
&             r1_mag-dot_ur1))**2
            edges = edges + ur1/(r1_mag*(r1_mag-dot_ur1))
          end if
! chordwise loop through horseshoe elements
          do el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            ad = bptsd(el_i+0, el_j+0, :)
            a = bpts(el_i+0, el_j+0, :)
            bd = bptsd(el_i+0, el_j+1, :)
            b = bpts(el_i+0, el_j+1, :)
            if (el_i .eq. nx_ - 1) then
              cd = c_ted
              c = c_te
              dd = d_ted
              d = d_te
            else
              cd = bptsd(el_i+1, el_j+1, :)
              c = bpts(el_i+1, el_j+1, :)
              dd = bptsd(el_i+1, el_j+0, :)
              d = bpts(el_i+1, el_j+0, :)
            end if
            call calc_vorticity_d(b, bd, c, cd, p, pd, edges, edgesd)
            call calc_vorticity_d(d, dd, a, ad, p, pd, edges, edgesd)
            bound(:) = 0.
            if (symmetry) then
              a_symd = ad
              a_sym = a
              b_symd = bd
              b_sym = b
              c_symd = cd
              c_sym = c
              d_symd = dd
              d_sym = d
              a_symd(2) = -a_symd(2)
              a_sym(2) = -a_sym(2)
              b_symd(2) = -b_symd(2)
              b_sym(2) = -b_sym(2)
              c_symd(2) = -c_symd(2)
              c_sym(2) = -c_sym(2)
              d_symd(2) = -d_symd(2)
              d_sym(2) = -d_sym(2)
              call calc_vorticity_d(c_sym, c_symd, b_sym, b_symd, p, pd&
&                             , edges, edgesd)
              call calc_vorticity_d(a_sym, a_symd, d_sym, d_symd, p, pd&
&                             , edges, edgesd)
              boundd = 0.0_8
              call calc_vorticity_d(b_sym, b_symd, a_sym, a_symd, p, pd&
&                             , bound, boundd)
            else
              boundd = 0.0_8
            end if
            if (.not.(skip .and. cp_loc .eq. el_loc)) call &
&             calc_vorticity_d(a, ad, b, bd, p, pd, bound, boundd)
            mtxd(cp_loc, el_loc, :) = edgesd + boundd
            mtx(cp_loc, el_loc, :) = edges + bound
          end do
        end do
      end do
    end do
  end subroutine assembleaeromtx_main_d
  subroutine assembleaeromtx_main(ny, nx, ny_, nx_, alpha, points, bpts&
&   , mesh, skip, symmetry, mtx)
    implicit none
! input
    integer, intent(in) :: ny, nx, ny_, nx_
    real(kind=8), intent(in) :: alpha, mesh(nx_, ny_, 3)
    real(kind=8), intent(in) :: points(nx-1, ny-1, 3), bpts(nx_-1, ny_, &
&   3)
    logical, intent(in) :: skip, symmetry
! output
    real(kind=8), intent(out) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
! working
    integer :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    real(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    real(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    real(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    real(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    real(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym(3)
    intrinsic atan
    intrinsic cos
    intrinsic sin
    pi = 4.d0*atan(1.d0)
! trailing vortices in avl follow the x-axis; no cos or sin
! u(1) = 1.
! u(3) = 0.
    u(1) = cos(alpha*pi/180.)
    u(2) = 0.
    u(3) = sin(alpha*pi/180.)
    mtx(:, :, :) = 0.
! spanwise loop through horseshoe elements
    do el_j=1,ny_-1
      el_loc_j = (el_j-1)*(nx_-1)
      c_te = mesh(nx_, el_j+1, :)
      d_te = mesh(nx_, el_j+0, :)
      if (symmetry) then
        c_te_sym = c_te
        d_te_sym = d_te
        c_te_sym(2) = -c_te_sym(2)
        d_te_sym(2) = -d_te_sym(2)
      end if
! spanwise loop through control points
      do cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        do cp_i=1,nx-1
          cp_loc = cp_i + cp_loc_j
          p = points(cp_i, cp_j, :)
          r1 = p - d_te
          r2 = p - c_te
          call norm(r1, r1_mag)
          call norm(r2, r2_mag)
          call cross(u, r2, ur2)
          call cross(u, r1, ur1)
          edges(:) = 0.
          call dot(u, r2, dot_ur2)
          call dot(u, r1, dot_ur1)
          edges = ur2/(r2_mag*(r2_mag-dot_ur2))
          edges = edges - ur1/(r1_mag*(r1_mag-dot_ur1))
          if (symmetry) then
            r1 = p - d_te_sym
            r2 = p - c_te_sym
            call norm(r1, r1_mag)
            call norm(r2, r2_mag)
            call cross(u, r2, ur2)
            call cross(u, r1, ur1)
            call dot(u, r2, dot_ur2)
            call dot(u, r1, dot_ur1)
            edges = edges - ur2/(r2_mag*(r2_mag-dot_ur2))
            edges = edges + ur1/(r1_mag*(r1_mag-dot_ur1))
          end if
! chordwise loop through horseshoe elements
          do el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            a = bpts(el_i+0, el_j+0, :)
            b = bpts(el_i+0, el_j+1, :)
            if (el_i .eq. nx_ - 1) then
              c = c_te
              d = d_te
            else
              c = bpts(el_i+1, el_j+1, :)
              d = bpts(el_i+1, el_j+0, :)
            end if
            call calc_vorticity(b, c, p, edges)
            call calc_vorticity(d, a, p, edges)
            bound(:) = 0.
            if (symmetry) then
              a_sym = a
              b_sym = b
              c_sym = c
              d_sym = d
              a_sym(2) = -a_sym(2)
              b_sym(2) = -b_sym(2)
              c_sym(2) = -c_sym(2)
              d_sym(2) = -d_sym(2)
              call calc_vorticity(c_sym, b_sym, p, edges)
              call calc_vorticity(a_sym, d_sym, p, edges)
              call calc_vorticity(b_sym, a_sym, p, bound)
            end if
            if (.not.(skip .and. cp_loc .eq. el_loc)) call &
&             calc_vorticity(a, b, p, bound)
            mtx(cp_loc, el_loc, :) = edges + bound
          end do
        end do
      end do
    end do
  end subroutine assembleaeromtx_main
!  differentiation of calc_vorticity in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: out
!   with respect to varying inputs: p out a b
  subroutine calc_vorticity_d(a, ad, b, bd, p, pd, out, outd)
    implicit none
! input
    real(kind=8), intent(in) :: a(3), b(3), p(3)
    real(kind=8), intent(in) :: ad(3), bd(3), pd(3)
! output
    real(kind=8), intent(inout) :: out(3)
    real(kind=8), intent(inout) :: outd(3)
! working
    real(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    real(kind=8) :: r1d(3), r2d(3), r1_magd, r2_magd, r1r2d(3), &
&   mag_multd, dot_r1r2d
    r1d = pd - ad
    r1 = p - a
    r2d = pd - bd
    r2 = p - b
    call norm_d(r1, r1d, r1_mag, r1_magd)
    call norm_d(r2, r2d, r2_mag, r2_magd)
    r1r2d = 0.0_8
    call cross_d(r1, r1d, r2, r2d, r1r2, r1r2d)
    mag_multd = r1_magd*r2_mag + r1_mag*r2_magd
    mag_mult = r1_mag*r2_mag
    call dot_d(r1, r1d, r2, r2d, dot_r1r2, dot_r1r2d)
    outd = outd + (((r1_magd+r2_magd)*r1r2+(r1_mag+r2_mag)*r1r2d)*&
&     mag_mult*(mag_mult+dot_r1r2)-(r1_mag+r2_mag)*r1r2*(mag_multd*(&
&     mag_mult+dot_r1r2)+mag_mult*(mag_multd+dot_r1r2d)))/(mag_mult*(&
&     mag_mult+dot_r1r2))**2
    out = out + (r1_mag+r2_mag)*r1r2/(mag_mult*(mag_mult+dot_r1r2))
  end subroutine calc_vorticity_d
  subroutine calc_vorticity(a, b, p, out)
    implicit none
! input
    real(kind=8), intent(in) :: a(3), b(3), p(3)
! output
    real(kind=8), intent(inout) :: out(3)
! working
    real(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    r1 = p - a
    r2 = p - b
    call norm(r1, r1_mag)
    call norm(r2, r2_mag)
    call cross(r1, r2, r1r2)
    mag_mult = r1_mag*r2_mag
    call dot(r1, r2, dot_r1r2)
    out = out + (r1_mag+r2_mag)*r1r2/(mag_mult*(mag_mult+dot_r1r2))
  end subroutine calc_vorticity
  subroutine biotsavart(a, b, p, inf, rev, out)
    implicit none
! input
    real(kind=8), intent(in) :: a(3), b(3), p(3)
    logical, intent(in) :: inf, rev
! output
    real(kind=8), intent(inout) :: out(3)
! working
    real(kind=8) :: rpa, rpb, rab, rh
    real(kind=8) :: cosa, cosb, c(3)
    real(kind=8) :: eps, tmp(3), dot_bapa, dot_baba, dot_pbab
    eps = 1e-5
    call norm(a - p, rpa)
    call norm(b - p, rpb)
    call norm(b - a, rab)
    call dot(b - a, p - a, dot_bapa)
    call dot(b - a, b - a, dot_baba)
    call dot(p - b, a - b, dot_pbab)
    call norm(p - a - dot_bapa/dot_baba*(b-a), rh)
    rh = rh + eps
    cosa = dot_bapa/(rpa*rab)
    cosb = dot_pbab/(rpb*rab)
    call cross(b - p, a - p, c)
    call unit(c, c)
    if (inf) then
      tmp = -(c/rh*(cosa+1))
    else
      tmp = -(c/rh*(cosa+cosb))
    end if
    if (rev) tmp = -tmp
    out = out + tmp
  end subroutine biotsavart
!  differentiation of forcecalc_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: sec_forces
!   with respect to varying inputs: v circ bpts rho
!   rw status of diff variables: v:in circ:in bpts:in sec_forces:out
!                rho:in
  subroutine forcecalc_main_d(v, vd, circ, circd, rho, rhod, bpts, bptsd&
&   , nx, ny, num_panels, sec_forces, sec_forcesd)
    implicit none
    integer, intent(in) :: nx, ny, num_panels
    real(kind=8), intent(in) :: v(num_panels, 3), circ(num_panels), rho&
&   , bpts(nx-1, ny, 3)
    real(kind=8), intent(in) :: vd(num_panels, 3), circd(num_panels), &
&   rhod, bptsd(nx-1, ny, 3)
    real(kind=8), intent(out) :: sec_forces(num_panels, 3)
    real(kind=8), intent(out) :: sec_forcesd(num_panels, 3)
    real(kind=8) :: bound(num_panels, 3), v_cross_bound(num_panels, 3), &
&   tmp(3)
    real(kind=8) :: boundd(num_panels, 3), v_cross_boundd(num_panels, 3)&
&   , tmpd(3)
    integer :: i, j, k
    boundd = 0.0_8
    do j=1,ny-1
      do i=1,nx-1
        boundd((j-1)*(nx-1)+i, :) = bptsd(i, j+1, :) - bptsd(i, j, :)
        bound((j-1)*(nx-1)+i, :) = bpts(i, j+1, :) - bpts(i, j, :)
      end do
    end do
    v_cross_boundd = 0.0_8
    tmpd = 0.0_8
    do i=1,num_panels
      call cross_d(v(i, :), vd(i, :), bound(i, :), boundd(i, :), tmp, &
&            tmpd)
      v_cross_boundd(i, :) = tmpd
      v_cross_bound(i, :) = tmp
    end do
    sec_forcesd = 0.0_8
    do i=1,3
      sec_forcesd(:, i) = (rhod*circ+rho*circd)*v_cross_bound(:, i) + &
&       rho*circ*v_cross_boundd(:, i)
      sec_forces(:, i) = rho*circ*v_cross_bound(:, i)
    end do
  end subroutine forcecalc_main_d
  subroutine forcecalc_main(v, circ, rho, bpts, nx, ny, num_panels, &
&   sec_forces)
    implicit none
    integer, intent(in) :: nx, ny, num_panels
    real(kind=8), intent(in) :: v(num_panels, 3), circ(num_panels), rho&
&   , bpts(nx-1, ny, 3)
    real(kind=8), intent(out) :: sec_forces(num_panels, 3)
    real(kind=8) :: bound(num_panels, 3), v_cross_bound(num_panels, 3), &
&   tmp(3)
    integer :: i, j, k
    do j=1,ny-1
      do i=1,nx-1
        bound((j-1)*(nx-1)+i, :) = bpts(i, j+1, :) - bpts(i, j, :)
      end do
    end do
    do i=1,num_panels
      call cross(v(i, :), bound(i, :), tmp)
      v_cross_bound(i, :) = tmp
    end do
    do i=1,3
      sec_forces(:, i) = rho*circ*v_cross_bound(:, i)
    end do
  end subroutine forcecalc_main
!  differentiation of momentcalc_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: m
!   with respect to varying inputs: chords s_ref bpts sec_forces
!                cg widths
!   rw status of diff variables: chords:in m:out s_ref:in bpts:in
!                sec_forces:in cg:in widths:in
  subroutine momentcalc_main_d(bpts, bptsd, cg, cgd, chords, chordsd, &
&   widths, widthsd, s_ref, s_refd, sec_forces, sec_forcesd, symmetry, &
&   nx, ny, m, md)
    implicit none
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: bpts(nx-1, ny, 3)
    real(kind=8), intent(in) :: bptsd(nx-1, ny, 3)
    real(kind=8), intent(in) :: cg(3), s_ref
    real(kind=8), intent(in) :: cgd(3), s_refd
    real(kind=8), intent(in) :: chords(ny), widths(ny-1)
    real(kind=8), intent(in) :: chordsd(ny), widthsd(ny-1)
    logical, intent(in) :: symmetry
    real(kind=8), intent(in) :: sec_forces(nx-1, ny-1, 3)
    real(kind=8), intent(in) :: sec_forcesd(nx-1, ny-1, 3)
    real(kind=8), intent(out) :: m(3)
    real(kind=8), intent(out) :: md(3)
    real(kind=8) :: panel_chords(ny-1), mac, moment(ny-1, 3), tmp(3)
    real(kind=8) :: panel_chordsd(ny-1), macd, momentd(ny-1, 3), tmpd(3)
    integer :: i, j, k
    intrinsic sum
    real(kind=8), dimension(ny-1) :: arg1
    real(kind=8), dimension(ny-1) :: arg1d
    panel_chordsd = (chordsd(2:)+chordsd(:ny-1))/2.
    panel_chords = (chords(2:)+chords(:ny-1))/2.
    arg1d(:) = 2*panel_chords*panel_chordsd*widths + panel_chords**2*&
&     widthsd
    arg1(:) = panel_chords**2*widths
    macd = sum(arg1d(:))/s_ref - s_refd*sum(arg1(:))/s_ref**2
    mac = 1./s_ref*sum(arg1(:))
    if (symmetry) then
      macd = 2*macd
      mac = mac*2
    end if
    moment(:, :) = 0.
    momentd = 0.0_8
    tmpd = 0.0_8
    do j=1,ny-1
      do i=1,nx-1
        call cross_d((bpts(i, j+1, :)+bpts(i, j, :))/2. - cg, (bptsd(i, &
&              j+1, :)+bptsd(i, j, :))/2. - cgd, sec_forces(i, j, :), &
&              sec_forcesd(i, j, :), tmp, tmpd)
        momentd(j, :) = momentd(j, :) + tmpd
        moment(j, :) = moment(j, :) + tmp
      end do
    end do
    momentd = (momentd*mac-moment*macd)/mac**2
    moment = moment/mac
    if (symmetry) then
      momentd(:, 1) = 0.0_8
      moment(:, 1) = 0.
      momentd(:, 2) = 2*momentd(:, 2)
      moment(:, 2) = moment(:, 2)*2
      momentd(:, 3) = 0.0_8
      moment(:, 3) = 0.
    end if
    m = 0.
    md = 0.0_8
    do j=1,ny-1
      md = md + momentd(j, :)
      m = m + moment(j, :)
    end do
  end subroutine momentcalc_main_d
  subroutine momentcalc_main(bpts, cg, chords, widths, s_ref, sec_forces&
&   , symmetry, nx, ny, m)
    implicit none
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: bpts(nx-1, ny, 3)
    real(kind=8), intent(in) :: cg(3), s_ref
    real(kind=8), intent(in) :: chords(ny), widths(ny-1)
    logical, intent(in) :: symmetry
    real(kind=8), intent(in) :: sec_forces(nx-1, ny-1, 3)
    real(kind=8), intent(out) :: m(3)
    real(kind=8) :: panel_chords(ny-1), mac, moment(ny-1, 3), tmp(3)
    integer :: i, j, k
    intrinsic sum
    real(kind=8), dimension(ny-1) :: arg1
    panel_chords = (chords(2:)+chords(:ny-1))/2.
    arg1(:) = panel_chords**2*widths
    mac = 1./s_ref*sum(arg1(:))
    if (symmetry) mac = mac*2
    moment(:, :) = 0.
    do j=1,ny-1
      do i=1,nx-1
        call cross((bpts(i, j+1, :)+bpts(i, j, :))/2. - cg, sec_forces(i&
&            , j, :), tmp)
        moment(j, :) = moment(j, :) + tmp
      end do
    end do
    moment = moment/mac
    if (symmetry) then
      moment(:, 1) = 0.
      moment(:, 2) = moment(:, 2)*2
      moment(:, 3) = 0.
    end if
    m = 0.
    do j=1,ny-1
      m = m + moment(j, :)
    end do
  end subroutine momentcalc_main
!  differentiation of compute_normals_main in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: s_ref normals
!   with respect to varying inputs: mesh
!   rw status of diff variables: s_ref:out mesh:in normals:out
  subroutine compute_normals_main_d(nx, ny, mesh, meshd, normals, &
&   normalsd, s_ref, s_refd)
    implicit none
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: mesh(nx, ny, 3)
    real(kind=8), intent(in) :: meshd(nx, ny, 3)
    real(kind=8), intent(out) :: normals(nx-1, ny-1, 3), s_ref
    real(kind=8), intent(out) :: normalsd(nx-1, ny-1, 3), s_refd
    integer :: i, j
    real(kind=8) :: norms(nx, ny), out(3)
    real(kind=8) :: normsd(nx, ny), outd(3)
    intrinsic sum
    intrinsic sqrt
    real(kind=8), dimension(3) :: arg1
    real(kind=8), dimension(3) :: arg1d
    real(kind=8) :: arg2
    real(kind=8) :: arg2d
    normalsd = 0.0_8
    outd = 0.0_8
    normsd = 0.0_8
    do i=1,nx-1
      do j=1,ny-1
        call cross_d(mesh(i, j+1, :) - mesh(i+1, j, :), meshd(i, j+1, :)&
&              - meshd(i+1, j, :), mesh(i, j, :) - mesh(i+1, j+1, :), &
&              meshd(i, j, :) - meshd(i+1, j+1, :), out, outd)
        normalsd(i, j, :) = outd
        normals(i, j, :) = out
        arg1d(:) = 2*normals(i, j, :)*normalsd(i, j, :)
        arg1(:) = normals(i, j, :)**2
        arg2d = sum(arg1d(:))
        arg2 = sum(arg1(:))
        if (arg2 .eq. 0.0_8) then
          normsd(i, j) = 0.0_8
        else
          normsd(i, j) = arg2d/(2.0*sqrt(arg2))
        end if
        norms(i, j) = sqrt(arg2)
        normalsd(i, j, :) = (normalsd(i, j, :)*norms(i, j)-normals(i, j&
&         , :)*normsd(i, j))/norms(i, j)**2
        normals(i, j, :) = normals(i, j, :)/norms(i, j)
      end do
    end do
    s_refd = 0.5*sum(normsd)
    s_ref = 0.5*sum(norms)
  end subroutine compute_normals_main_d
  subroutine compute_normals_main(nx, ny, mesh, normals, s_ref)
    implicit none
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: mesh(nx, ny, 3)
    real(kind=8), intent(out) :: normals(nx-1, ny-1, 3), s_ref
    integer :: i, j
    real(kind=8) :: norms(nx, ny), out(3)
    intrinsic sum
    intrinsic sqrt
    real(kind=8), dimension(3) :: arg1
    real(kind=8) :: arg2
    do i=1,nx-1
      do j=1,ny-1
        call cross(mesh(i, j+1, :) - mesh(i+1, j, :), mesh(i, j, :) - &
&            mesh(i+1, j+1, :), out)
        normals(i, j, :) = out
        arg1(:) = normals(i, j, :)**2
        arg2 = sum(arg1(:))
        norms(i, j) = sqrt(arg2)
        normals(i, j, :) = normals(i, j, :)/norms(i, j)
      end do
    end do
    s_ref = 0.5*sum(norms)
  end subroutine compute_normals_main
!  differentiation of unit in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: u
!   with respect to varying inputs: u v
! real functions
  subroutine unit_d(v, vd, u, ud)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(in) :: vd(3)
    real(kind=8), intent(out) :: u(3)
    real(kind=8), intent(out) :: ud(3)
    real(kind=8) :: nm
    real(kind=8) :: nmd
    call norm_d(v, vd, nm, nmd)
    ud(1) = (vd(1)*nm-v(1)*nmd)/nm**2
    u(1) = v(1)/nm
    ud(2) = (vd(2)*nm-v(2)*nmd)/nm**2
    u(2) = v(2)/nm
    ud(3) = (vd(3)*nm-v(3)*nmd)/nm**2
    u(3) = v(3)/nm
  end subroutine unit_d
! real functions
  subroutine unit(v, u)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(out) :: u(3)
    real(kind=8) :: nm
    call norm(v, nm)
    u(1) = v(1)/nm
    u(2) = v(2)/nm
    u(3) = v(3)/nm
  end subroutine unit
!  differentiation of norm in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: norm_output
!   with respect to varying inputs: v
  subroutine norm_d(v, vd, norm_output, norm_outputd)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(in) :: vd(3)
    real(kind=8), intent(out) :: norm_output
    real(kind=8), intent(out) :: norm_outputd
    real(kind=8) :: dot_prod, v1(3)
    real(kind=8) :: dot_prodd, v1d(3)
! need to create a copy of v here so the reverse mode ad works correctly
    v1d = vd
    v1 = v
!norm = sqrt(dot_product(v, v))
    call dot_d(v, vd, v1, v1d, dot_prod, dot_prodd)
    if (dot_prod .gt. 0.0_8) then
      norm_outputd = 0.5*dot_prod**(-0.5)*dot_prodd
    else
      norm_outputd = 0.0_8
    end if
    norm_output = dot_prod**0.5
  end subroutine norm_d
  subroutine norm(v, norm_output)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(out) :: norm_output
    real(kind=8) :: dot_prod, v1(3)
! need to create a copy of v here so the reverse mode ad works correctly
    v1 = v
!norm = sqrt(dot_product(v, v))
    call dot(v, v1, dot_prod)
    norm_output = dot_prod**0.5
  end subroutine norm
!  differentiation of dot in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: dot_prod
!   with respect to varying inputs: a b
  subroutine dot_d(a, ad, b, bd, dot_prod, dot_prodd)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(in) :: ad(3), bd(3)
    real(kind=8), intent(out) :: dot_prod
    real(kind=8), intent(out) :: dot_prodd
    dot_prodd = ad(1)*b(1) + a(1)*bd(1) + ad(2)*b(2) + a(2)*bd(2) + ad(3&
&     )*b(3) + a(3)*bd(3)
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dot_d
  subroutine dot(a, b, dot_prod)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(out) :: dot_prod
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dot
!  differentiation of cross in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: c
!   with respect to varying inputs: a b c
  subroutine cross_d(a, ad, b, bd, c, cd)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(in) :: ad(3), bd(3)
    real(kind=8), intent(out) :: c(3)
    real(kind=8), intent(out) :: cd(3)
    cd(1) = ad(2)*b(3) + a(2)*bd(3) - ad(3)*b(2) - a(3)*bd(2)
    c(1) = a(2)*b(3) - a(3)*b(2)
    cd(2) = ad(3)*b(1) + a(3)*bd(1) - ad(1)*b(3) - a(1)*bd(3)
    c(2) = a(3)*b(1) - a(1)*b(3)
    cd(3) = ad(1)*b(2) + a(1)*bd(2) - ad(2)*b(1) - a(2)*bd(1)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine cross_d
  subroutine cross(a, b, c)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(out) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine cross
end module oas_main_d
