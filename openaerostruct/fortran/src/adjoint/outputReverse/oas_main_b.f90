!        generated by tapenade     (inria, tropics team)
!  tapenade 3.10 (r5363) -  9 sep 2014 09:53
!
module oas_main_b
  implicit none

contains
!  differentiation of manipulate_mesh_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: span yshear taper sweep chord
!                mesh twist dihedral xshear zshear
!   with respect to varying inputs: span yshear taper sweep chord
!                mesh twist dihedral xshear zshear
!   rw status of diff variables: span:incr yshear:incr taper:incr
!                sweep:incr chord:incr mesh:in-zero twist:incr
!                dihedral:incr xshear:incr zshear:incr
  subroutine manipulate_mesh_main_b(nx, ny, input_mesh, taper, taperb, &
&   chord, chordb, sweep, sweepb, xshear, xshearb, span, spanb, yshear, &
&   yshearb, dihedral, dihedralb, zshear, zshearb, twist, twistb, &
&   symmetry, rotate_x, mesh, meshb)
    implicit none
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: input_mesh(nx, ny, 3), taper, chord(ny)
    real(kind=8) :: taperb, chordb(ny)
    real(kind=8), intent(in) :: sweep, xshear(ny), span, yshear(ny)
    real(kind=8) :: sweepb, xshearb(ny), spanb, yshearb(ny)
    real(kind=8), intent(in) :: dihedral, zshear(ny), twist(ny)
    real(kind=8) :: dihedralb, zshearb(ny), twistb(ny)
    logical, intent(in) :: symmetry, rotate_x
    real(kind=8) :: mesh(nx, ny, 3)
    real(kind=8) :: meshb(nx, ny, 3)
    real(kind=8) :: le(ny, 3), te(ny, 3), quarter_chord(ny, 3), p180, &
&   tan_theta
    real(kind=8) :: leb(ny, 3), teb(ny, 3), quarter_chordb(ny, 3), &
&   tan_thetab
    real(kind=8) :: dx(ny), y0, rad_twist(ny), rotation_matrix(ny, 3, 3)
    real(kind=8) :: dxb(ny), y0b, rad_twistb(ny), rotation_matrixb(ny, 3&
&   , 3)
    real(kind=8) :: row(ny, 3), out(3), taper_lins(ny), taper_lins_sym((&
&   ny+1)/2)
    real(kind=8) :: rowb(ny, 3), outb(3), taper_linsb(ny)
    real(kind=8) :: rad_theta_x(ny), one, dz_qc(ny-1), dy_qc(ny-1), s(ny&
&   ), new_span
    real(kind=8) :: rad_theta_xb(ny), dz_qcb(ny-1), dy_qcb(ny-1), sb(ny)&
&   , new_spanb
    real(kind=8) :: dz_qc_l((ny-1)/2), dz_qc_r((ny-1)/2), dy_qc_l((ny-1)&
&   /2), dy_qc_r((ny-1)/2)
    real(kind=8) :: dz_qc_lb((ny-1)/2), dz_qc_rb((ny-1)/2), dy_qc_lb((ny&
&   -1)/2), dy_qc_rb((ny-1)/2)
    real(kind=8) :: computed_span
    integer :: ny2, ix, iy, ind
    intrinsic tan
    intrinsic atan
    intrinsic cos
    intrinsic sin
    real(kind=8), dimension(3) :: arg1
    real(kind=8), dimension(3) :: arg1b
    integer :: ad_to
    integer :: ad_to0
    integer :: ad_to1
    integer :: branch
    real(kind=8) :: tempb3((ny-1)/2)
    real(kind=8) :: tempb2((ny-1)/2)
    real(kind=8) :: tempb1(ny-1)
    real(kind=8) :: tempb0
    real(kind=8) :: tempb(ny)
    p180 = 3.14159265358979323846264338/180.
    mesh = input_mesh
! taper
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    quarter_chord = 0.25*te + 0.75*le
    if (symmetry) then
      computed_span = quarter_chord(ny, 2) - quarter_chord(1, 2)
      do iy=1,ny
        taper_lins(iy) = (quarter_chord(iy, 2)-quarter_chord(1, 2))/&
&         computed_span*(1-taper) + taper
      end do
      do iy=1,ny
        do ix=1,nx
          do ind=1,3
            call pushreal8(mesh(ix, iy, ind))
            mesh(ix, iy, ind) = (mesh(ix, iy, ind)-quarter_chord(iy, ind&
&             ))*taper_lins(iy) + quarter_chord(iy, ind)
          end do
        end do
      end do
      call pushcontrol1b(0)
    else
      computed_span = quarter_chord(ny, 2) - quarter_chord(1, 2)
      ny2 = (ny-1)/2
      do iy=1,ny2
        dx(iy) = 1 + quarter_chord(iy, 2)/(computed_span/2)*taper
      end do
      call pushinteger4(iy - 1)
      do iy=1,ny2
        dx(iy) = (quarter_chord(iy, 2)-quarter_chord(1, 2))/(&
&         computed_span/2)*(1-taper) + taper
      end do
      call pushinteger4(iy - 1)
      do iy=ny,ny2+1,-1
        dx(iy) = -((quarter_chord(iy, 2)-quarter_chord(ny, 2))/(&
&         computed_span/2)*(1-taper)) + taper
      end do
      call pushinteger4(iy + 1)
      do iy=1,ny
        do ix=1,nx
          do ind=1,3
            call pushreal8(mesh(ix, iy, ind))
            mesh(ix, iy, ind) = (mesh(ix, iy, ind)-quarter_chord(iy, ind&
&             ))*dx(iy) + quarter_chord(iy, ind)
          end do
        end do
      end do
      call pushcontrol1b(1)
    end if
! scale x
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    call pushreal8array(quarter_chord, ny*3)
    quarter_chord = 0.25*te + 0.75*le
    do iy=1,ny
      call pushreal8array(mesh(:, iy, 1), nx)
      mesh(:, iy, 1) = (mesh(:, iy, 1)-quarter_chord(iy, 1))*chord(iy) +&
&       quarter_chord(iy, 1)
    end do
! sweep
    le = mesh(1, :, :)
    tan_theta = tan(p180*sweep)
    if (symmetry) then
      y0 = le(ny, 2)
      call pushreal8array(dx, ny)
      dx = -((le(:, 2)-y0)*tan_theta)
      call pushcontrol1b(1)
    else
      ny2 = (ny-1)/2
      y0 = le(ny2+1, 2)
      call pushreal8array(dx(1:ny2), ny2)
      dx(:ny2) = -((le(:ny2, 2)-y0)*tan_theta)
      call pushreal8array(dx(ny2+1:ny), ny - ny2)
      dx(ny2+1:) = (le(ny2+1:, 2)-y0)*tan_theta
      call pushcontrol1b(0)
    end if
    do ix=1,nx
      mesh(ix, :, 1) = mesh(ix, :, 1) + dx
    end do
! x shear
    do ix=1,nx
      mesh(ix, :, 1) = mesh(ix, :, 1) + xshear
    end do
! span
    call pushreal8array(le, ny*3)
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    call pushreal8array(quarter_chord, ny*3)
    quarter_chord = 0.25*te + 0.75*le
    new_span = span
    if (symmetry) then
      new_span = span/2.
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    s = quarter_chord(:, 2)/(quarter_chord(ny, 2)-quarter_chord(1, 2))
    do ix=1,nx
      mesh(ix, :, 2) = s*new_span
    end do
! y shear
    do ix=1,nx
      mesh(ix, :, 2) = mesh(ix, :, 2) + yshear
    end do
! dihedral
    le = mesh(1, :, :)
    call pushreal8(tan_theta)
    tan_theta = tan(p180*dihedral)
    if (symmetry) then
      call pushreal8(y0)
      y0 = le(ny, 2)
      call pushreal8array(dx, ny)
      dx = -((le(:, 2)-y0)*tan_theta)
      call pushcontrol1b(1)
    else
      ny2 = (ny-1)/2
      call pushreal8(y0)
      y0 = le(ny2+1, 2)
      call pushreal8array(dx(1:ny2), ny2)
      dx(:ny2) = -((le(:ny2, 2)-y0)*tan_theta)
      call pushreal8array(dx(ny2+1:ny), ny - ny2)
      dx(ny2+1:) = (le(ny2+1:, 2)-y0)*tan_theta
      call pushcontrol1b(0)
    end if
    do ix=1,nx
      mesh(ix, :, 3) = mesh(ix, :, 3) + dx
    end do
! z shear
    do ix=1,nx
      mesh(ix, :, 3) = mesh(ix, :, 3) + zshear
    end do
! rotate
    call pushreal8array(le, ny*3)
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    call pushreal8array(quarter_chord, ny*3)
    quarter_chord = 0.25*te + 0.75*le
    rad_theta_x(:) = 0.
    if (rotate_x) then
      if (symmetry) then
        dz_qc = quarter_chord(:ny-1, 3) - quarter_chord(2:, 3)
        dy_qc = quarter_chord(:ny-1, 2) - quarter_chord(2:, 2)
        rad_theta_x(:ny-1) = atan(dz_qc/dy_qc)
        call pushcontrol2b(0)
      else
        ny2 = (ny-1)/2
        dz_qc_l = quarter_chord(:ny2, 3) - quarter_chord(2:ny2+1, 3)
        dy_qc_l = quarter_chord(:ny2, 2) - quarter_chord(2:ny2+1, 2)
        rad_theta_x(:ny2) = atan(dz_qc_l/dy_qc_l)
        dz_qc_r = quarter_chord(ny2+2:, 3) - quarter_chord(ny2+1:ny-1, 3&
&         )
        dy_qc_r = quarter_chord(ny2+2:, 2) - quarter_chord(ny2+1:ny-1, 2&
&         )
        rad_theta_x(ny2+2:) = atan(dz_qc_r/dy_qc_r)
        call pushcontrol2b(1)
      end if
    else
      call pushcontrol2b(2)
    end if
    rad_twist = twist*p180
    rotation_matrix(:, :, :) = 0.
    rotation_matrix(:, 1, 1) = cos(rad_twist)
    rotation_matrix(:, 1, 3) = sin(rad_twist)
    rotation_matrix(:, 2, 1) = sin(rad_theta_x)*sin(rad_twist)
    rotation_matrix(:, 2, 2) = cos(rad_theta_x)
    rotation_matrix(:, 2, 3) = -(sin(rad_theta_x)*cos(rad_twist))
    rotation_matrix(:, 3, 1) = -(cos(rad_theta_x)*sin(rad_twist))
    rotation_matrix(:, 3, 2) = sin(rad_theta_x)
    rotation_matrix(:, 3, 3) = cos(rad_theta_x)*cos(rad_twist)
    do ix=1,nx
      row = mesh(ix, :, :)
    end do
    quarter_chordb = 0.0_8
    rotation_matrixb = 0.0_8
    do ix=nx,1,-1
      quarter_chordb = quarter_chordb + meshb(ix, :, :)
      rowb = 0.0_8
      do iy=ny,1,-1
        outb = 0.0_8
        outb = meshb(ix, iy, :)
        meshb(ix, iy, :) = 0.0_8
        row = mesh(ix, :, :)
        arg1(:) = row(iy, :) - quarter_chord(iy, :)
        arg1b = 0.0_8
        call matmul2_b(3, 3, 1, rotation_matrix(iy, :, :), &
&                rotation_matrixb(iy, :, :), arg1(:), arg1b(:), out, &
&                outb)
        rowb(iy, :) = rowb(iy, :) + arg1b
        quarter_chordb(iy, :) = quarter_chordb(iy, :) - arg1b
      end do
      meshb(ix, :, :) = meshb(ix, :, :) + rowb
    end do
    rad_theta_xb = 0.0_8
    rad_twistb = 0.0_8
    rad_theta_xb = -(cos(rad_twist)*sin(rad_theta_x)*rotation_matrixb(:&
&     , 3, 3))
    rad_twistb = -(cos(rad_theta_x)*sin(rad_twist)*rotation_matrixb(:, 3&
&     , 3))
    rotation_matrixb(:, 3, 3) = 0.0_8
    rad_theta_xb = rad_theta_xb + cos(rad_theta_x)*rotation_matrixb(:, 3&
&     , 2)
    rotation_matrixb(:, 3, 2) = 0.0_8
    rad_theta_xb = rad_theta_xb + sin(rad_twist)*sin(rad_theta_x)*&
&     rotation_matrixb(:, 3, 1)
    rad_twistb = rad_twistb - cos(rad_theta_x)*cos(rad_twist)*&
&     rotation_matrixb(:, 3, 1)
    rotation_matrixb(:, 3, 1) = 0.0_8
    rad_theta_xb = rad_theta_xb - cos(rad_twist)*cos(rad_theta_x)*&
&     rotation_matrixb(:, 2, 3)
    rad_twistb = rad_twistb + sin(rad_theta_x)*sin(rad_twist)*&
&     rotation_matrixb(:, 2, 3)
    rotation_matrixb(:, 2, 3) = 0.0_8
    rad_theta_xb = rad_theta_xb - sin(rad_theta_x)*rotation_matrixb(:, 2&
&     , 2)
    rotation_matrixb(:, 2, 2) = 0.0_8
    rad_theta_xb = rad_theta_xb + sin(rad_twist)*cos(rad_theta_x)*&
&     rotation_matrixb(:, 2, 1)
    rad_twistb = rad_twistb + sin(rad_theta_x)*cos(rad_twist)*&
&     rotation_matrixb(:, 2, 1)
    rotation_matrixb(:, 2, 1) = 0.0_8
    rad_twistb = rad_twistb + cos(rad_twist)*rotation_matrixb(:, 1, 3)
    rotation_matrixb(:, 1, 3) = 0.0_8
    rad_twistb = rad_twistb - sin(rad_twist)*rotation_matrixb(:, 1, 1)
    twistb = twistb + p180*rad_twistb
    call popcontrol2b(branch)
    if (branch .eq. 0) then
      dy_qcb = 0.0_8
      dz_qcb = 0.0_8
      tempb1 = rad_theta_xb(:ny-1)/(dy_qc*(1.0+(dz_qc/dy_qc)**2))
      dz_qcb = tempb1
      dy_qcb = -(dz_qc*tempb1/dy_qc)
      quarter_chordb(1:ny-1, 2) = quarter_chordb(1:ny-1, 2) + dy_qcb
      quarter_chordb(2:ny, 2) = quarter_chordb(2:ny, 2) - dy_qcb
      quarter_chordb(1:ny-1, 3) = quarter_chordb(1:ny-1, 3) + dz_qcb
      quarter_chordb(2:ny, 3) = quarter_chordb(2:ny, 3) - dz_qcb
    else if (branch .eq. 1) then
      dy_qc_rb = 0.0_8
      dz_qc_rb = 0.0_8
      tempb2 = rad_theta_xb(ny2+2:)/(dy_qc_r*(1.0+(dz_qc_r/dy_qc_r)**2))
      dz_qc_rb = tempb2
      dy_qc_rb = -(dz_qc_r*tempb2/dy_qc_r)
      rad_theta_xb(ny2+2:ny) = 0.0_8
      quarter_chordb(ny2+2:ny, 2) = quarter_chordb(ny2+2:ny, 2) + &
&       dy_qc_rb
      quarter_chordb(ny2+1:ny-1, 2) = quarter_chordb(ny2+1:ny-1, 2) - &
&       dy_qc_rb
      quarter_chordb(ny2+2:ny, 3) = quarter_chordb(ny2+2:ny, 3) + &
&       dz_qc_rb
      quarter_chordb(ny2+1:ny-1, 3) = quarter_chordb(ny2+1:ny-1, 3) - &
&       dz_qc_rb
      dy_qc_lb = 0.0_8
      dz_qc_lb = 0.0_8
      tempb3 = rad_theta_xb(:ny2)/(dy_qc_l*(1.0+(dz_qc_l/dy_qc_l)**2))
      dz_qc_lb = tempb3
      dy_qc_lb = -(dz_qc_l*tempb3/dy_qc_l)
      quarter_chordb(1:ny2, 2) = quarter_chordb(1:ny2, 2) + dy_qc_lb
      quarter_chordb(2:ny2+1, 2) = quarter_chordb(2:ny2+1, 2) - dy_qc_lb
      quarter_chordb(1:ny2, 3) = quarter_chordb(1:ny2, 3) + dz_qc_lb
      quarter_chordb(2:ny2+1, 3) = quarter_chordb(2:ny2+1, 3) - dz_qc_lb
    end if
    leb = 0.0_8
    teb = 0.0_8
    call popreal8array(quarter_chord, ny*3)
    teb = 0.25*quarter_chordb
    leb = 0.75*quarter_chordb
    meshb(nx, :, :) = meshb(nx, :, :) + teb
    call popreal8array(le, ny*3)
    meshb(1, :, :) = meshb(1, :, :) + leb
    do ix=nx,1,-1
      zshearb = zshearb + meshb(ix, :, 3)
    end do
    dxb = 0.0_8
    do ix=nx,1,-1
      dxb = dxb + meshb(ix, :, 3)
    end do
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      ny2 = (ny-1)/2
      leb = 0.0_8
      call popreal8array(dx(ny2+1:ny), ny - ny2)
      leb(ny2+1:ny, 2) = leb(ny2+1:ny, 2) + tan_theta*dxb(ny2+1:ny)
      y0b = -(tan_theta*sum(dxb(ny2+1:)))
      tan_thetab = sum((le(ny2+1:, 2)-y0)*dxb(ny2+1:))
      dxb(ny2+1:ny) = 0.0_8
      call popreal8array(dx(1:ny2), ny2)
      leb(1:ny2, 2) = leb(1:ny2, 2) - tan_theta*dxb(1:ny2)
      y0b = y0b + tan_theta*sum(dxb(:ny2))
      tan_thetab = tan_thetab - sum((le(:ny2, 2)-y0)*dxb(:ny2))
      dxb(1:ny2) = 0.0_8
      call popreal8(y0)
      leb(ny2+1, 2) = leb(ny2+1, 2) + y0b
    else
      leb = 0.0_8
      call popreal8array(dx, ny)
      leb(:, 2) = leb(:, 2) - tan_theta*dxb
      y0b = tan_theta*sum(dxb)
      tan_thetab = -sum((le(:, 2)-y0)*dxb)
      call popreal8(y0)
      leb(ny, 2) = leb(ny, 2) + y0b
      dxb = 0.0_8
    end if
    call popreal8(tan_theta)
    dihedralb = dihedralb + (1.0+tan(p180*dihedral)**2)*p180*tan_thetab
    meshb(1, :, :) = meshb(1, :, :) + leb
    do ix=nx,1,-1
      yshearb = yshearb + meshb(ix, :, 2)
    end do
    sb = 0.0_8
    new_spanb = 0.0_8
    do ix=nx,1,-1
      sb = sb + new_span*meshb(ix, :, 2)
      new_spanb = new_spanb + sum(s*meshb(ix, :, 2))
      meshb(ix, :, 2) = 0.0_8
    end do
    quarter_chordb = 0.0_8
    tempb = sb/(quarter_chord(ny, 2)-quarter_chord(1, 2))
    tempb0 = sum(-(quarter_chord(:, 2)*tempb/(quarter_chord(ny, 2)-&
&     quarter_chord(1, 2))))
    quarter_chordb(:, 2) = quarter_chordb(:, 2) + tempb
    quarter_chordb(ny, 2) = quarter_chordb(ny, 2) + tempb0
    quarter_chordb(1, 2) = quarter_chordb(1, 2) - tempb0
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      spanb = spanb + new_spanb/2.
      new_spanb = 0.0_8
    end if
    spanb = spanb + new_spanb
    leb = 0.0_8
    teb = 0.0_8
    call popreal8array(quarter_chord, ny*3)
    teb = 0.25*quarter_chordb
    leb = 0.75*quarter_chordb
    meshb(nx, :, :) = meshb(nx, :, :) + teb
    call popreal8array(le, ny*3)
    meshb(1, :, :) = meshb(1, :, :) + leb
    do ix=nx,1,-1
      xshearb = xshearb + meshb(ix, :, 1)
    end do
    do ix=nx,1,-1
      dxb = dxb + meshb(ix, :, 1)
    end do
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      ny2 = (ny-1)/2
      leb = 0.0_8
      call popreal8array(dx(ny2+1:ny), ny - ny2)
      leb(ny2+1:ny, 2) = leb(ny2+1:ny, 2) + tan_theta*dxb(ny2+1:ny)
      y0b = -(tan_theta*sum(dxb(ny2+1:)))
      tan_thetab = sum((le(ny2+1:, 2)-y0)*dxb(ny2+1:))
      dxb(ny2+1:ny) = 0.0_8
      call popreal8array(dx(1:ny2), ny2)
      leb(1:ny2, 2) = leb(1:ny2, 2) - tan_theta*dxb(1:ny2)
      y0b = y0b + tan_theta*sum(dxb(:ny2))
      tan_thetab = tan_thetab - sum((le(:ny2, 2)-y0)*dxb(:ny2))
      dxb(1:ny2) = 0.0_8
      leb(ny2+1, 2) = leb(ny2+1, 2) + y0b
    else
      leb = 0.0_8
      call popreal8array(dx, ny)
      leb(:, 2) = leb(:, 2) - tan_theta*dxb
      y0b = tan_theta*sum(dxb)
      tan_thetab = -sum((le(:, 2)-y0)*dxb)
      leb(ny, 2) = leb(ny, 2) + y0b
      dxb = 0.0_8
    end if
    sweepb = sweepb + (1.0+tan(p180*sweep)**2)*p180*tan_thetab
    meshb(1, :, :) = meshb(1, :, :) + leb
    quarter_chordb = 0.0_8
    do iy=ny,1,-1
      call popreal8array(mesh(:, iy, 1), nx)
      quarter_chordb(iy, 1) = quarter_chordb(iy, 1) + sum(meshb(:, iy, 1&
&       )) - chord(iy)*sum(meshb(:, iy, 1))
      chordb(iy) = chordb(iy) + sum((mesh(:, iy, 1)-quarter_chord(iy, 1)&
&       )*meshb(:, iy, 1))
      meshb(:, iy, 1) = chord(iy)*meshb(:, iy, 1)
    end do
    leb = 0.0_8
    teb = 0.0_8
    call popreal8array(quarter_chord, ny*3)
    teb = 0.25*quarter_chordb
    leb = 0.75*quarter_chordb
    meshb(nx, :, :) = meshb(nx, :, :) + teb
    meshb(1, :, :) = meshb(1, :, :) + leb
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      taper_linsb = 0.0_8
      do iy=ny,1,-1
        do ix=nx,1,-1
          do ind=3,1,-1
            call popreal8(mesh(ix, iy, ind))
            taper_linsb(iy) = taper_linsb(iy) + (mesh(ix, iy, ind)-&
&             quarter_chord(iy, ind))*meshb(ix, iy, ind)
            meshb(ix, iy, ind) = taper_lins(iy)*meshb(ix, iy, ind)
          end do
        end do
      end do
      do iy=ny,1,-1
        taperb = taperb + (1.0_8-(quarter_chord(iy, 2)-quarter_chord(1, &
&         2))/computed_span)*taper_linsb(iy)
        taper_linsb(iy) = 0.0_8
      end do
    else
      do iy=ny,1,-1
        do ix=nx,1,-1
          do ind=3,1,-1
            call popreal8(mesh(ix, iy, ind))
            dxb(iy) = dxb(iy) + (mesh(ix, iy, ind)-quarter_chord(iy, ind&
&             ))*meshb(ix, iy, ind)
            meshb(ix, iy, ind) = dx(iy)*meshb(ix, iy, ind)
          end do
        end do
      end do
      call popinteger4(ad_to1)
      do iy=ad_to1,ny,1
        taperb = taperb + ((quarter_chord(iy, 2)-quarter_chord(ny, 2))*2&
&         /computed_span+1.0_8)*dxb(iy)
        dxb(iy) = 0.0_8
      end do
      call popinteger4(ad_to0)
      do iy=ad_to0,1,-1
        taperb = taperb + (1.0_8-(quarter_chord(iy, 2)-quarter_chord(1, &
&         2))*2/computed_span)*dxb(iy)
        dxb(iy) = 0.0_8
      end do
      call popinteger4(ad_to)
      do iy=ad_to,1,-1
        taperb = taperb + quarter_chord(iy, 2)*2*dxb(iy)/computed_span
        dxb(iy) = 0.0_8
      end do
    end if
    meshb = 0.0_8
  end subroutine manipulate_mesh_main_b
  subroutine manipulate_mesh_main(nx, ny, input_mesh, taper, chord, &
&   sweep, xshear, span, yshear, dihedral, zshear, twist, symmetry, &
&   rotate_x, mesh)
    implicit none
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: input_mesh(nx, ny, 3), taper, chord(ny)
    real(kind=8), intent(in) :: sweep, xshear(ny), span, yshear(ny)
    real(kind=8), intent(in) :: dihedral, zshear(ny), twist(ny)
    logical, intent(in) :: symmetry, rotate_x
    real(kind=8), intent(out) :: mesh(nx, ny, 3)
    real(kind=8) :: le(ny, 3), te(ny, 3), quarter_chord(ny, 3), p180, &
&   tan_theta
    real(kind=8) :: dx(ny), y0, rad_twist(ny), rotation_matrix(ny, 3, 3)
    real(kind=8) :: row(ny, 3), out(3), taper_lins(ny), taper_lins_sym((&
&   ny+1)/2)
    real(kind=8) :: rad_theta_x(ny), one, dz_qc(ny-1), dy_qc(ny-1), s(ny&
&   ), new_span
    real(kind=8) :: dz_qc_l((ny-1)/2), dz_qc_r((ny-1)/2), dy_qc_l((ny-1)&
&   /2), dy_qc_r((ny-1)/2)
    real(kind=8) :: computed_span
    integer :: ny2, ix, iy, ind
    intrinsic tan
    intrinsic atan
    intrinsic cos
    intrinsic sin
    real(kind=8), dimension(3) :: arg1
    p180 = 3.14159265358979323846264338/180.
    mesh = input_mesh
    one = 1.
! taper
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    quarter_chord = 0.25*te + 0.75*le
    if (symmetry) then
      computed_span = quarter_chord(ny, 2) - quarter_chord(1, 2)
      do iy=1,ny
        taper_lins(iy) = (quarter_chord(iy, 2)-quarter_chord(1, 2))/&
&         computed_span*(1-taper) + taper
      end do
      do iy=1,ny
        do ix=1,nx
          do ind=1,3
            mesh(ix, iy, ind) = (mesh(ix, iy, ind)-quarter_chord(iy, ind&
&             ))*taper_lins(iy) + quarter_chord(iy, ind)
          end do
        end do
      end do
    else
      computed_span = quarter_chord(ny, 2) - quarter_chord(1, 2)
      ny2 = (ny-1)/2
      do iy=1,ny2
        dx(iy) = 1 + quarter_chord(iy, 2)/(computed_span/2)*taper
      end do
      do iy=1,ny2
        dx(iy) = (quarter_chord(iy, 2)-quarter_chord(1, 2))/(&
&         computed_span/2)*(1-taper) + taper
      end do
      do iy=ny,ny2+1,-1
        dx(iy) = -((quarter_chord(iy, 2)-quarter_chord(ny, 2))/(&
&         computed_span/2)*(1-taper)) + taper
      end do
      do iy=1,ny
        do ix=1,nx
          do ind=1,3
            mesh(ix, iy, ind) = (mesh(ix, iy, ind)-quarter_chord(iy, ind&
&             ))*dx(iy) + quarter_chord(iy, ind)
          end do
        end do
      end do
    end if
! scale x
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    quarter_chord = 0.25*te + 0.75*le
    do iy=1,ny
      mesh(:, iy, 1) = (mesh(:, iy, 1)-quarter_chord(iy, 1))*chord(iy) +&
&       quarter_chord(iy, 1)
    end do
! sweep
    le = mesh(1, :, :)
    tan_theta = tan(p180*sweep)
    if (symmetry) then
      y0 = le(ny, 2)
      dx = -((le(:, 2)-y0)*tan_theta)
    else
      ny2 = (ny-1)/2
      y0 = le(ny2+1, 2)
      dx(:ny2) = -((le(:ny2, 2)-y0)*tan_theta)
      dx(ny2+1:) = (le(ny2+1:, 2)-y0)*tan_theta
    end if
    do ix=1,nx
      mesh(ix, :, 1) = mesh(ix, :, 1) + dx
    end do
! x shear
    do ix=1,nx
      mesh(ix, :, 1) = mesh(ix, :, 1) + xshear
    end do
! span
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    quarter_chord = 0.25*te + 0.75*le
    new_span = span
    if (symmetry) new_span = span/2.
    s = quarter_chord(:, 2)/(quarter_chord(ny, 2)-quarter_chord(1, 2))
    do ix=1,nx
      mesh(ix, :, 2) = s*new_span
    end do
! y shear
    do ix=1,nx
      mesh(ix, :, 2) = mesh(ix, :, 2) + yshear
    end do
! dihedral
    le = mesh(1, :, :)
    tan_theta = tan(p180*dihedral)
    if (symmetry) then
      y0 = le(ny, 2)
      dx = -((le(:, 2)-y0)*tan_theta)
    else
      ny2 = (ny-1)/2
      y0 = le(ny2+1, 2)
      dx(:ny2) = -((le(:ny2, 2)-y0)*tan_theta)
      dx(ny2+1:) = (le(ny2+1:, 2)-y0)*tan_theta
    end if
    do ix=1,nx
      mesh(ix, :, 3) = mesh(ix, :, 3) + dx
    end do
! z shear
    do ix=1,nx
      mesh(ix, :, 3) = mesh(ix, :, 3) + zshear
    end do
! rotate
    le = mesh(1, :, :)
    te = mesh(nx, :, :)
    quarter_chord = 0.25*te + 0.75*le
    rad_theta_x(:) = 0.
    if (rotate_x) then
      if (symmetry) then
        dz_qc = quarter_chord(:ny-1, 3) - quarter_chord(2:, 3)
        dy_qc = quarter_chord(:ny-1, 2) - quarter_chord(2:, 2)
        rad_theta_x(:ny-1) = atan(dz_qc/dy_qc)
      else
        ny2 = (ny-1)/2
        dz_qc_l = quarter_chord(:ny2, 3) - quarter_chord(2:ny2+1, 3)
        dy_qc_l = quarter_chord(:ny2, 2) - quarter_chord(2:ny2+1, 2)
        rad_theta_x(:ny2) = atan(dz_qc_l/dy_qc_l)
        dz_qc_r = quarter_chord(ny2+2:, 3) - quarter_chord(ny2+1:ny-1, 3&
&         )
        dy_qc_r = quarter_chord(ny2+2:, 2) - quarter_chord(ny2+1:ny-1, 2&
&         )
        rad_theta_x(ny2+2:) = atan(dz_qc_r/dy_qc_r)
      end if
    end if
    rad_twist = twist*p180
    rotation_matrix(:, :, :) = 0.
    rotation_matrix(:, 1, 1) = cos(rad_twist)
    rotation_matrix(:, 1, 3) = sin(rad_twist)
    rotation_matrix(:, 2, 1) = sin(rad_theta_x)*sin(rad_twist)
    rotation_matrix(:, 2, 2) = cos(rad_theta_x)
    rotation_matrix(:, 2, 3) = -(sin(rad_theta_x)*cos(rad_twist))
    rotation_matrix(:, 3, 1) = -(cos(rad_theta_x)*sin(rad_twist))
    rotation_matrix(:, 3, 2) = sin(rad_theta_x)
    rotation_matrix(:, 3, 3) = cos(rad_theta_x)*cos(rad_twist)
    do ix=1,nx
      row = mesh(ix, :, :)
      do iy=1,ny
        arg1(:) = row(iy, :) - quarter_chord(iy, :)
        call matmul2(3, 3, 1, rotation_matrix(iy, :, :), arg1(:), out)
        mesh(ix, iy, :) = out
      end do
      mesh(ix, :, :) = mesh(ix, :, :) + quarter_chord
    end do
  end subroutine manipulate_mesh_main
  subroutine linspace(l, k, n, z)
    implicit none
!// argument declarations
    integer, intent(in) :: n
    real(kind=8), dimension(n), intent(out) :: z
    real(kind=8), intent(in) :: l
    real(kind=8), intent(in) :: k
!// local variables
    integer :: i
    real(kind=8) :: d
    d = (k-l)/(n-1)
    z(1) = l
    do i=2,n-1
      z(i) = z(i-1) + d
    end do
    z(1) = l
    z(n) = k
    return
  end subroutine linspace
!  differentiation of calc_vonmises_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: r vonmises nodes disp
!   with respect to varying inputs: r vonmises nodes disp
!   rw status of diff variables: r:incr vonmises:in-zero nodes:incr
!                disp:incr
  subroutine calc_vonmises_main_b(nodes, nodesb, r, rb, disp, dispb, e, &
&   g, x_gl, n, vonmises, vonmisesb)
    implicit none
! input
    integer, intent(in) :: n
    real(kind=8), intent(in) :: nodes(n, 3), r(n-1), disp(n, 6)
    real(kind=8) :: nodesb(n, 3), rb(n-1), dispb(n, 6)
    real(kind=8), intent(in) :: e, g, x_gl(3)
    real(kind=8) :: x_glb(3)
! output
    real(kind=8) :: vonmises(n-1, 2)
    real(kind=8) :: vonmisesb(n-1, 2)
! working
    integer :: ielem
    real(kind=8) :: p0(3), p1(3), l, x_loc(3), y_loc(3), z_loc(3), t(3, &
&   3)
    real(kind=8) :: p0b(3), p1b(3), lb, x_locb(3), y_locb(3), z_locb(3)&
&   , tb(3, 3)
    real(kind=8) :: u0(3), r0(3), u1(3), r1(3), sxx0, sxx1, sxt, tmp
    real(kind=8) :: u0b(3), r0b(3), u1b(3), r1b(3), sxx0b, sxx1b, sxtb, &
&   tmpb
    real(kind=8) :: y_raw(3), z_raw(3), r1r0(3), t1(3), t2(3), t3(3), t4&
&   (3)
    real(kind=8) :: y_rawb(3), z_rawb(3), r1r0b(3), t1b(3), t2b(3), t3b(&
&   3), t4b(3)
    real(kind=8) :: nodes2(n, 3), r2(n-1), disp2(n, 6), p1p0(3)
    real(kind=8) :: nodes2b(n, 3), r2b(n-1), disp2b(n, 6), p1p0b(3)
    real(kind=8) :: tempb6
    real(kind=8) :: tempb5
    real(kind=8) :: tempb4
    real(kind=8) :: tempb3
    real(kind=8) :: tempb2
    real(kind=8) :: tempb1
    real(kind=8) :: tempb0
    real(kind=8) :: tempb
    real(kind=8) :: temp
    nodes2 = nodes
    r2 = r
    disp2 = disp
    do ielem=1,n-1
      p0 = nodes2(ielem, :)
      p1 = nodes2(ielem+1, :)
      p1p0 = p1 - p0
      call pushreal8(l)
      call norm(p1p0, l)
      call pushreal8array(x_loc, 3)
      call unit(p1p0, x_loc)
      call pushreal8array(y_raw, 3)
      call cross(x_loc, x_gl, y_raw)
      call pushreal8array(y_loc, 3)
      call unit(y_raw, y_loc)
      call pushreal8array(z_raw, 3)
      call cross(x_loc, y_loc, z_raw)
      call unit(z_raw, z_loc)
      call pushreal8array(t(1, :), 3)
      t(1, :) = x_loc
      call pushreal8array(t(2, :), 3)
      t(2, :) = y_loc
      call pushreal8array(t(3, :), 3)
      t(3, :) = z_loc
      t1 = disp2(ielem, 1:3)
      t2 = disp2(ielem, 4:6)
      t3 = disp2(ielem+1, 1:3)
      t4 = disp2(ielem+1, 4:6)
      call pushreal8array(u0, 3)
      call matmul2(3, 3, 1, t, t1, u0)
      call matmul2(3, 3, 1, t, t2, r0)
      call pushreal8array(u1, 3)
      call matmul2(3, 3, 1, t, t3, u1)
      call matmul2(3, 3, 1, t, t4, r1)
      call pushreal8array(r1r0, 3)
      r1r0 = r1 - r0
    end do
    y_locb = 0.0_8
    tb = 0.0_8
    nodes2b = 0.0_8
    z_locb = 0.0_8
    y_rawb = 0.0_8
    r2b = 0.0_8
    z_rawb = 0.0_8
    disp2b = 0.0_8
    x_locb = 0.0_8
    do ielem=n-1,1,-1
      sxt = g*r2(ielem)*r1r0(1)/l
      tmp = (r1r0(2)**2+r1r0(3)**2)**.5
      sxx1 = e*(u0(1)-u1(1))/l + e*r2(ielem)/l*tmp
      tempb = .5*(sxx1**2+3*sxt**2)**(-0.5)*vonmisesb(ielem, 2)
      sxx1b = 2*sxx1*tempb
      vonmisesb(ielem, 2) = 0.0_8
      sxx0 = e*(u1(1)-u0(1))/l + e*r2(ielem)/l*tmp
      tempb0 = .5*(sxx0**2+3*sxt**2)**(-0.5)*vonmisesb(ielem, 1)
      sxtb = 3*2*sxt*tempb0 + 3*2*sxt*tempb
      sxx0b = 2*sxx0*tempb0
      vonmisesb(ielem, 1) = 0.0_8
      r1r0b = 0.0_8
      temp = r1r0(1)/l
      tempb1 = r2(ielem)*g*sxtb/l
      r2b(ielem) = r2b(ielem) + e*tmp*sxx1b/l + e*tmp*sxx0b/l + g*temp*&
&       sxtb
      r1r0b(1) = r1r0b(1) + tempb1
      u0b = 0.0_8
      u1b = 0.0_8
      tempb2 = e*sxx1b/l
      tempb3 = r2(ielem)*e*sxx1b/l
      tempb5 = e*sxx0b/l
      u0b(1) = u0b(1) + tempb2 - tempb5
      u1b(1) = u1b(1) + tempb5 - tempb2
      tempb4 = r2(ielem)*e*sxx0b/l
      lb = -((u0(1)-u1(1))*tempb2/l) - tmp*tempb3/l - tmp*tempb4/l - (u1&
&       (1)-u0(1))*tempb5/l - temp*tempb1
      tmpb = tempb4 + tempb3
      tempb6 = .5*(r1r0(2)**2+r1r0(3)**2)**(-0.5)*tmpb
      r1r0b(2) = r1r0b(2) + 2*r1r0(2)*tempb6
      r1r0b(3) = r1r0b(3) + 2*r1r0(3)*tempb6
      r0b = 0.0_8
      r1b = 0.0_8
      call popreal8array(r1r0, 3)
      r1b = r1r0b
      r0b = -r1r0b
      t4 = disp2(ielem+1, 4:6)
      t4b = 0.0_8
      call matmul2_b(3, 3, 1, t, tb, t4, t4b, r1, r1b)
      t3 = disp2(ielem+1, 1:3)
      call popreal8array(u1, 3)
      t3b = 0.0_8
      call matmul2_b(3, 3, 1, t, tb, t3, t3b, u1, u1b)
      t2 = disp2(ielem, 4:6)
      t2b = 0.0_8
      call matmul2_b(3, 3, 1, t, tb, t2, t2b, r0, r0b)
      t1 = disp2(ielem, 1:3)
      call popreal8array(u0, 3)
      t1b = 0.0_8
      call matmul2_b(3, 3, 1, t, tb, t1, t1b, u0, u0b)
      disp2b(ielem+1, 4:6) = disp2b(ielem+1, 4:6) + t4b
      disp2b(ielem+1, 1:3) = disp2b(ielem+1, 1:3) + t3b
      disp2b(ielem, 4:6) = disp2b(ielem, 4:6) + t2b
      disp2b(ielem, 1:3) = disp2b(ielem, 1:3) + t1b
      call popreal8array(t(3, :), 3)
      z_locb = z_locb + tb(3, :)
      tb(3, :) = 0.0_8
      call popreal8array(t(2, :), 3)
      y_locb = y_locb + tb(2, :)
      tb(2, :) = 0.0_8
      call popreal8array(t(1, :), 3)
      x_locb = x_locb + tb(1, :)
      tb(1, :) = 0.0_8
      call unit_b(z_raw, z_rawb, z_loc, z_locb)
      call popreal8array(z_raw, 3)
      call cross_b(x_loc, x_locb, y_loc, y_locb, z_raw, z_rawb)
      call popreal8array(y_loc, 3)
      call unit_b(y_raw, y_rawb, y_loc, y_locb)
      call popreal8array(y_raw, 3)
      x_glb = 0.0_8
      call cross_b(x_loc, x_locb, x_gl, x_glb, y_raw, y_rawb)
      p0 = nodes2(ielem, :)
      p1 = nodes2(ielem+1, :)
      p1p0 = p1 - p0
      call popreal8array(x_loc, 3)
      p1p0b = 0.0_8
      call unit_b(p1p0, p1p0b, x_loc, x_locb)
      call popreal8(l)
      call norm_b(p1p0, p1p0b, l, lb)
      p0b = 0.0_8
      p1b = 0.0_8
      p1b = p1p0b
      p0b = -p1p0b
      nodes2b(ielem+1, :) = nodes2b(ielem+1, :) + p1b
      nodes2b(ielem, :) = nodes2b(ielem, :) + p0b
    end do
    dispb = dispb + disp2b
    rb = rb + r2b
    nodesb = nodesb + nodes2b
    vonmisesb = 0.0_8
  end subroutine calc_vonmises_main_b
  subroutine calc_vonmises_main(nodes, r, disp, e, g, x_gl, n, vonmises)
    implicit none
! input
    integer, intent(in) :: n
    real(kind=8), intent(in) :: nodes(n, 3), r(n-1), disp(n, 6)
    real(kind=8), intent(in) :: e, g, x_gl(3)
! output
    real(kind=8), intent(out) :: vonmises(n-1, 2)
! working
    integer :: ielem
    real(kind=8) :: p0(3), p1(3), l, x_loc(3), y_loc(3), z_loc(3), t(3, &
&   3)
    real(kind=8) :: u0(3), r0(3), u1(3), r1(3), sxx0, sxx1, sxt, tmp
    real(kind=8) :: y_raw(3), z_raw(3), r1r0(3), t1(3), t2(3), t3(3), t4&
&   (3)
    real(kind=8) :: nodes2(n, 3), r2(n-1), disp2(n, 6), p1p0(3)
    vonmises(:, :) = 0.
    nodes2 = nodes
    r2 = r
    disp2 = disp
    do ielem=1,n-1
      p0 = nodes2(ielem, :)
      p1 = nodes2(ielem+1, :)
      p1p0 = p1 - p0
      call norm(p1p0, l)
      call unit(p1p0, x_loc)
      call cross(x_loc, x_gl, y_raw)
      call unit(y_raw, y_loc)
      call cross(x_loc, y_loc, z_raw)
      call unit(z_raw, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      t1 = disp2(ielem, 1:3)
      t2 = disp2(ielem, 4:6)
      t3 = disp2(ielem+1, 1:3)
      t4 = disp2(ielem+1, 4:6)
      call matmul2(3, 3, 1, t, t1, u0)
      call matmul2(3, 3, 1, t, t2, r0)
      call matmul2(3, 3, 1, t, t3, u1)
      call matmul2(3, 3, 1, t, t4, r1)
      r1r0 = r1 - r0
      tmp = (r1r0(2)**2+r1r0(3)**2)**.5
      sxx0 = e*(u1(1)-u0(1))/l + e*r2(ielem)/l*tmp
      sxx1 = e*(u0(1)-u1(1))/l + e*r2(ielem)/l*tmp
      sxt = g*r2(ielem)*r1r0(1)/l
      vonmises(ielem, 1) = (sxx0**2+3*sxt**2)**.5
      vonmises(ielem, 2) = (sxx1**2+3*sxt**2)**.5
    end do
  end subroutine calc_vonmises_main
!  differentiation of transferdisplacements_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: mesh def_mesh disp
!   with respect to varying inputs: mesh def_mesh disp
!   rw status of diff variables: mesh:incr def_mesh:in-zero disp:incr
  subroutine transferdisplacements_main_b(nx, ny, mesh, meshb, disp, &
&   dispb, w, def_mesh, def_meshb)
    implicit none
! input
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: mesh(nx, ny, 3), disp(ny, 6), w
    real(kind=8) :: meshb(nx, ny, 3), dispb(ny, 6)
! output
    real(kind=8) :: def_mesh(nx, ny, 3)
    real(kind=8) :: def_meshb(nx, ny, 3)
! working
    integer :: ind, indx
    real(kind=8) :: smesh(nx, ny, 3), t(3, 3), t_base(3, 3), vec(3)
    real(kind=8) :: smeshb(nx, ny, 3), tb(3, 3), vecb(3)
    real(kind=8) :: sinr(3), cosr(3), r(3), ref_curve(ny, 3)
    real(kind=8) :: sinrb(3), cosrb(3), rb(3), ref_curveb(ny, 3)
    intrinsic cos
    intrinsic sin
    ref_curve = (1-w)*mesh(1, :, :) + w*mesh(nx, :, :)
    t_base(:, :) = 0.
    do ind=1,3
      t_base(ind, ind) = -2.
    end do
    do ind=1,nx
      smesh(ind, :, :) = mesh(ind, :, :) - ref_curve
    end do
    do ind=1,ny
      r = disp(ind, 4:6)
      cosr = cos(r)
      sinr = sin(r)
      call pushreal8array(t, 3**2)
      t(:, :) = 0.
      t(1, 1) = cosr(3) + cosr(2)
      t(2, 2) = cosr(3) + cosr(1)
      t(3, 3) = cosr(1) + cosr(2)
      t(1, 2) = -sinr(3)
      t(1, 3) = sinr(2)
      t(2, 1) = sinr(3)
      t(2, 3) = -sinr(1)
      t(3, 1) = -sinr(2)
      t(3, 2) = sinr(1)
      t = t + t_base
    end do
    meshb = meshb + def_meshb
    smeshb = 0.0_8
    do ind=ny,1,-1
      dispb(ind, 3) = dispb(ind, 3) + sum(def_meshb(:, ind, 3))
      dispb(ind, 2) = dispb(ind, 2) + sum(def_meshb(:, ind, 2))
      dispb(ind, 1) = dispb(ind, 1) + sum(def_meshb(:, ind, 1))
      tb = 0.0_8
      do indx=nx,1,-1
        vecb = 0.0_8
        vecb = def_meshb(indx, ind, :)
        call matmul2_b(3, 3, 1, t, tb, smesh(indx, ind, :), smeshb(indx&
&                , ind, :), vec, vecb)
      end do
      sinrb = 0.0_8
      sinrb(1) = sinrb(1) + tb(3, 2)
      tb(3, 2) = 0.0_8
      sinrb(2) = sinrb(2) - tb(3, 1)
      tb(3, 1) = 0.0_8
      sinrb(1) = sinrb(1) - tb(2, 3)
      tb(2, 3) = 0.0_8
      sinrb(3) = sinrb(3) + tb(2, 1)
      tb(2, 1) = 0.0_8
      sinrb(2) = sinrb(2) + tb(1, 3)
      tb(1, 3) = 0.0_8
      sinrb(3) = sinrb(3) - tb(1, 2)
      tb(1, 2) = 0.0_8
      cosrb = 0.0_8
      cosrb(1) = cosrb(1) + tb(3, 3)
      cosrb(2) = cosrb(2) + tb(3, 3)
      tb(3, 3) = 0.0_8
      cosrb(3) = cosrb(3) + tb(2, 2)
      cosrb(1) = cosrb(1) + tb(2, 2)
      tb(2, 2) = 0.0_8
      cosrb(3) = cosrb(3) + tb(1, 1)
      cosrb(2) = cosrb(2) + tb(1, 1)
      call popreal8array(t, 3**2)
      r = disp(ind, 4:6)
      rb = 0.0_8
      rb = cos(r)*sinrb - sin(r)*cosrb
      dispb(ind, 4:6) = dispb(ind, 4:6) + rb
    end do
    ref_curveb = 0.0_8
    do ind=nx,1,-1
      meshb(ind, :, :) = meshb(ind, :, :) + smeshb(ind, :, :)
      ref_curveb = ref_curveb - smeshb(ind, :, :)
      smeshb(ind, :, :) = 0.0_8
    end do
    meshb(1, :, :) = meshb(1, :, :) + (1-w)*ref_curveb
    meshb(nx, :, :) = meshb(nx, :, :) + w*ref_curveb
    def_meshb = 0.0_8
  end subroutine transferdisplacements_main_b
  subroutine transferdisplacements_main(nx, ny, mesh, disp, w, def_mesh)
    implicit none
! input
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: mesh(nx, ny, 3), disp(ny, 6), w
! output
    real(kind=8), intent(out) :: def_mesh(nx, ny, 3)
! working
    integer :: ind, indx
    real(kind=8) :: smesh(nx, ny, 3), t(3, 3), t_base(3, 3), vec(3)
    real(kind=8) :: sinr(3), cosr(3), r(3), ref_curve(ny, 3)
    intrinsic cos
    intrinsic sin
    ref_curve = (1-w)*mesh(1, :, :) + w*mesh(nx, :, :)
    def_mesh(:, :, :) = 0.
    t_base(:, :) = 0.
    do ind=1,3
      t_base(ind, ind) = -2.
    end do
    do ind=1,nx
      smesh(ind, :, :) = mesh(ind, :, :) - ref_curve
    end do
    do ind=1,ny
      r = disp(ind, 4:6)
      cosr = cos(r)
      sinr = sin(r)
      t(:, :) = 0.
      t(1, 1) = cosr(3) + cosr(2)
      t(2, 2) = cosr(3) + cosr(1)
      t(3, 3) = cosr(1) + cosr(2)
      t(1, 2) = -sinr(3)
      t(1, 3) = sinr(2)
      t(2, 1) = sinr(3)
      t(2, 3) = -sinr(1)
      t(3, 1) = -sinr(2)
      t(3, 2) = sinr(1)
      t = t + t_base
      do indx=1,nx
        call matmul2(3, 3, 1, t, smesh(indx, ind, :), vec)
        def_mesh(indx, ind, :) = def_mesh(indx, ind, :) + vec
      end do
      def_mesh(:, ind, 1) = def_mesh(:, ind, 1) + disp(ind, 1)
      def_mesh(:, ind, 2) = def_mesh(:, ind, 2) + disp(ind, 2)
      def_mesh(:, ind, 3) = def_mesh(:, ind, 3) + disp(ind, 3)
    end do
    def_mesh = def_mesh + mesh
  end subroutine transferdisplacements_main
!  differentiation of transferloads_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: loads sec_forces def_mesh
!   with respect to varying inputs: loads sec_forces def_mesh
!   rw status of diff variables: loads:in-zero sec_forces:incr
!                def_mesh:incr
  subroutine transferloads_main_b(nx, ny, def_mesh, def_meshb, &
&   sec_forces, sec_forcesb, fem_origin, loads, loadsb)
    implicit none
! input
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: def_mesh(nx, ny, 3), sec_forces(nx-1, ny&
&   -1, 3), fem_origin
    real(kind=8) :: def_meshb(nx, ny, 3), sec_forcesb(nx-1, ny-1, 3)
! output
    real(kind=8) :: loads(ny, 6)
    real(kind=8) :: loadsb(ny, 6)
! working
    integer :: ind, indy
    real(kind=8) :: w, moment(ny-1, 3), a_pts(nx-1, ny-1, 3), s_pts(ny-1&
&   , 3)
    real(kind=8) :: momentb(ny-1, 3), a_ptsb(nx-1, ny-1, 3), s_ptsb(ny-1&
&   , 3)
    real(kind=8) :: diff(3), tmp(3), sec_forces_sum(ny-1, 3)
    real(kind=8) :: diffb(3), tmpb(3), sec_forces_sumb(ny-1, 3)
! compute the aerodynamic centers at the quarter-chord point of each panel
    w = 0.25
    a_pts = 0.5*(1-w)*def_mesh(:nx-1, :ny-1, :) + 0.5*w*def_mesh(2:, :ny&
&     -1, :) + 0.5*(1-w)*def_mesh(:nx-1, 2:, :) + 0.5*w*def_mesh(2:, 2:&
&     , :)
! compute the structural midpoints based on the fem_origin location
    w = fem_origin
    s_pts = 0.5*(1-w)*def_mesh(1, :ny-1, :) + 0.5*w*def_mesh(nx, :ny-1, &
&     :) + 0.5*(1-w)*def_mesh(1, 2:, :) + 0.5*w*def_mesh(nx, 2:, :)
! find the moment arm between the aerodynamic centers of each panel
! and the fem elements
    momentb = 0.0_8
    momentb = 0.5*loadsb(:ny-1, 4:) + 0.5*loadsb(2:, 4:)
    sec_forces_sumb = 0.0_8
    sec_forces_sumb = 0.5*loadsb(:ny-1, :3) + 0.5*loadsb(2:, :3)
    do ind=nx-1,1,-1
      sec_forcesb(ind, :, :) = sec_forcesb(ind, :, :) + sec_forces_sumb
    end do
    s_ptsb = 0.0_8
    a_ptsb = 0.0_8
    do ind=nx-1,1,-1
      do indy=ny-1,1,-1
        tmpb = 0.0_8
        tmpb = momentb(indy, :)
        diff = a_pts(ind, indy, :) - s_pts(indy, :)
        diffb = 0.0_8
        call cross_b(diff, diffb, sec_forces(ind, indy, :), sec_forcesb(&
&              ind, indy, :), tmp, tmpb)
        a_ptsb(ind, indy, :) = a_ptsb(ind, indy, :) + diffb
        s_ptsb(indy, :) = s_ptsb(indy, :) - diffb
      end do
    end do
    def_meshb(1, 1:ny-1, :) = def_meshb(1, 1:ny-1, :) + (1-w)*0.5*s_ptsb
    def_meshb(nx, 1:ny-1, :) = def_meshb(nx, 1:ny-1, :) + w*0.5*s_ptsb
    def_meshb(1, 2:ny, :) = def_meshb(1, 2:ny, :) + (1-w)*0.5*s_ptsb
    def_meshb(nx, 2:ny, :) = def_meshb(nx, 2:ny, :) + w*0.5*s_ptsb
    w = 0.25
    def_meshb(1:nx-1, 1:ny-1, :) = def_meshb(1:nx-1, 1:ny-1, :) + (1-w)*&
&     0.5*a_ptsb
    def_meshb(2:nx, 1:ny-1, :) = def_meshb(2:nx, 1:ny-1, :) + w*0.5*&
&     a_ptsb
    def_meshb(1:nx-1, 2:ny, :) = def_meshb(1:nx-1, 2:ny, :) + (1-w)*0.5*&
&     a_ptsb
    def_meshb(2:nx, 2:ny, :) = def_meshb(2:nx, 2:ny, :) + w*0.5*a_ptsb
    loadsb = 0.0_8
  end subroutine transferloads_main_b
  subroutine transferloads_main(nx, ny, def_mesh, sec_forces, fem_origin&
&   , loads)
    implicit none
! input
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: def_mesh(nx, ny, 3), sec_forces(nx-1, ny&
&   -1, 3), fem_origin
! output
    real(kind=8), intent(out) :: loads(ny, 6)
! working
    integer :: ind, indy
    real(kind=8) :: w, moment(ny-1, 3), a_pts(nx-1, ny-1, 3), s_pts(ny-1&
&   , 3)
    real(kind=8) :: diff(3), tmp(3), sec_forces_sum(ny-1, 3)
! compute the aerodynamic centers at the quarter-chord point of each panel
    w = 0.25
    a_pts = 0.5*(1-w)*def_mesh(:nx-1, :ny-1, :) + 0.5*w*def_mesh(2:, :ny&
&     -1, :) + 0.5*(1-w)*def_mesh(:nx-1, 2:, :) + 0.5*w*def_mesh(2:, 2:&
&     , :)
! compute the structural midpoints based on the fem_origin location
    w = fem_origin
    s_pts = 0.5*(1-w)*def_mesh(1, :ny-1, :) + 0.5*w*def_mesh(nx, :ny-1, &
&     :) + 0.5*(1-w)*def_mesh(1, 2:, :) + 0.5*w*def_mesh(nx, 2:, :)
! find the moment arm between the aerodynamic centers of each panel
! and the fem elements
    moment = 0.
    do ind=1,nx-1
      do indy=1,ny-1
        diff = a_pts(ind, indy, :) - s_pts(indy, :)
        tmp = 0.
        call cross(diff, sec_forces(ind, indy, :), tmp)
        moment(indy, :) = moment(indy, :) + tmp
      end do
    end do
! compute the loads based on the xyz forces and the computed moments
    sec_forces_sum = 0.
    do ind=1,nx-1
      sec_forces_sum = sec_forces_sum + sec_forces(ind, :, :)
    end do
    loads = 0.
    loads(:ny-1, :3) = loads(:ny-1, :3) + 0.5*sec_forces_sum
    loads(2:, :3) = loads(2:, :3) + 0.5*sec_forces_sum
    loads(:ny-1, 4:) = loads(:ny-1, 4:) + 0.5*moment
    loads(2:, 4:) = loads(2:, 4:) + 0.5*moment
  end subroutine transferloads_main
!  differentiation of assemblestructmtx_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: k
!   with respect to varying inputs: j k nodes iy iz a
!   rw status of diff variables: j:out k:in-zero nodes:out iy:out
!                iz:out a:out
  subroutine assemblestructmtx_main_b(n, tot_n_fem, nodes, nodesb, a, ab&
&   , j, jb, iy, iyb, iz, izb, k_a, k_t, k_y, k_z, cons, e, g, x_gl, t, &
&   k_elem, pelem_a, pelem_t, pelem_y, pelem_z, t_elem, const2, const_y&
&   , const_z, k, kb)
    implicit none
! input
    integer, intent(in) :: n, cons, tot_n_fem
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    real(kind=8) :: nodesb(tot_n_fem, 3), ab(n-1), jb(n-1), iyb(n-1), &
&   izb(n-1)
    real(kind=8), intent(in) :: e, g, x_gl(3)
    real(kind=8) :: x_glb(3)
    real(kind=8), intent(inout) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    real(kind=8), intent(inout) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    real(kind=8) :: pelem_ab(2, 12), pelem_tb(2, 12), pelem_yb(4, 12), &
&   pelem_zb(4, 12)
    real(kind=8), intent(in) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4)
! output
    real(kind=8) :: k(6*n+6, 6*n+6)
    real(kind=8) :: kb(6*n+6, 6*n+6)
! working
    real(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    real(kind=8) :: p0b(3), p1b(3), x_locb(3), y_locb(3), z_locb(3), &
&   x_crossb(3), y_crossb(3)
    real(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    real(kind=8) :: lb, ea_lb, gj_lb, eiy_l3b, eiz_l3b, resb(12, 12)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    real(kind=8) :: mat12x12b(12, 12), mat12x4b(12, 4), mat12x2b(12, 2)
    integer :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(6*n+6, 6*n+6)
    real(kind=8) :: pelem_a_tb(12, 2), pelem_t_tb(12, 2)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)
    real(kind=8) :: pelem_y_tb(12, 4), pelem_z_tb(12, 4), t_elem_tb(12, &
&   12)
    real(kind=8), dimension(3) :: arg1
    real(kind=8), dimension(3) :: arg1b
    real(kind=8) :: temp0
    real(kind=8) :: tb(3, 3)
    real(kind=8) :: k_elemb(12, 12)
    real(kind=8) :: k_yb(4, 4)
    real(kind=8) :: tempb2
    real(kind=8) :: tempb1
    real(kind=8) :: tempb0
    real(kind=8) :: tempb
    real(kind=8) :: k_ab(2, 2)
    real(kind=8) :: t_elemb(12, 12)
    real(kind=8) :: k_tb(2, 2)
    real(kind=8) :: k_zb(4, 4)
    real(kind=8) :: temp
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
! loop over num elements
    do ielem=1,num_elems
      p0 = nodes(ielem, :)
      p1 = nodes(ielem+1, :)
      arg1(:) = p1 - p0
      call pushreal8array(x_loc, 3)
      call unit(arg1(:), x_loc)
      call pushreal8array(x_cross, 3)
      call cross(x_loc, x_gl, x_cross)
      call pushreal8array(y_loc, 3)
      call unit(x_cross, y_loc)
      call pushreal8array(y_cross, 3)
      call cross(x_loc, y_loc, y_cross)
      call unit(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      do ind=1,4
        call pushreal8array(t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:&
&                     3*(ind-1)+3), 3**2)
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      end do
      arg1(:) = p1 - p0
      call pushreal8(l)
      call norm(arg1(:), l)
      ea_l = e*a(ielem)/l
      gj_l = g*j(ielem)/l
      eiy_l3 = e*iy(ielem)/l**3
      eiz_l3 = e*iz(ielem)/l**3
      k_a(:, :) = ea_l*const2
      k_t(:, :) = gj_l*const2
      call pushreal8array(k_y, 4**2)
      k_y(:, :) = eiy_l3*const_y
      call pushreal8array(k_y(2, :), 4)
      k_y(2, :) = k_y(2, :)*l
      call pushreal8array(k_y(4, :), 4)
      k_y(4, :) = k_y(4, :)*l
      call pushreal8array(k_y(:, 2), 4)
      k_y(:, 2) = k_y(:, 2)*l
      call pushreal8array(k_y(:, 4), 4)
      k_y(:, 4) = k_y(:, 4)*l
      call pushreal8array(k_z, 4**2)
      k_z(:, :) = eiz_l3*const_z
      call pushreal8array(k_z(2, :), 4)
      k_z(2, :) = k_z(2, :)*l
      call pushreal8array(k_z(4, :), 4)
      k_z(4, :) = k_z(4, :)*l
      call pushreal8array(k_z(:, 2), 4)
      k_z(:, 2) = k_z(:, 2)*l
      call pushreal8array(k_z(:, 4), 4)
      k_z(:, 4) = k_z(:, 4)*l
      call pushreal8array(k_elem, 12**2)
      k_elem(:, :) = 0.
      call pushreal8array(pelem_a_t, 12*2)
      call transpose2(2, 12, pelem_a, pelem_a_t)
      call pushreal8array(mat12x2, 12*2)
      call matmul2(12, 2, 2, pelem_a_t, k_a, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      call pushreal8array(pelem_t_t, 12*2)
      call transpose2(2, 12, pelem_t, pelem_t_t)
      call pushreal8array(mat12x2, 12*2)
      call matmul2(12, 2, 2, pelem_t_t, k_t, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      call pushreal8array(pelem_y_t, 12*4)
      call transpose2(4, 12, pelem_y, pelem_y_t)
      call pushreal8array(mat12x4, 12*4)
      call matmul2(12, 4, 4, pelem_y_t, k_y, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      call pushreal8array(pelem_z_t, 12*4)
      call transpose2(4, 12, pelem_z, pelem_z_t)
      call pushreal8array(mat12x4, 12*4)
      call matmul2(12, 4, 4, pelem_z_t, k_z, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      call pushreal8array(t_elem_t, 12**2)
      call transpose2(12, 12, t_elem, t_elem_t)
      call pushreal8array(mat12x12, 12**2)
      call matmul2(12, 12, 12, t_elem_t, k_elem, mat12x12)
    end do
    do i=6,1,-1
      kb(6*cons+i, 6*num_nodes+i) = 0.0_8
      kb(6*num_nodes+i, 6*cons+i) = 0.0_8
    end do
    jb = 0.0_8
    tb = 0.0_8
    t_elemb = 0.0_8
    nodesb = 0.0_8
    iyb = 0.0_8
    izb = 0.0_8
    ab = 0.0_8
    y_locb = 0.0_8
    z_locb = 0.0_8
    t_elem_tb = 0.0_8
    y_crossb = 0.0_8
    x_crossb = 0.0_8
    x_locb = 0.0_8
    do ielem=num_elems,1,-1
      in1 = ielem + 1
      resb = 0.0_8
      resb(7:12, 7:12) = resb(7:12, 7:12) + kb(6*(in1-1)+1:6*(in1-1)+6, &
&       6*(in1-1)+1:6*(in1-1)+6)
      in0 = ielem
      resb(1:6, 7:12) = resb(1:6, 7:12) + kb(6*(in0-1)+1:6*(in0-1)+6, 6*&
&       (in1-1)+1:6*(in1-1)+6)
      resb(7:12, 1:6) = resb(7:12, 1:6) + kb(6*(in1-1)+1:6*(in1-1)+6, 6*&
&       (in0-1)+1:6*(in0-1)+6)
      resb(1:6, 1:6) = resb(1:6, 1:6) + kb(6*(in0-1)+1:6*(in0-1)+6, 6*(&
&       in0-1)+1:6*(in0-1)+6)
      mat12x12b = 0.0_8
      call matmul2_b(12, 12, 12, mat12x12, mat12x12b, t_elem, t_elemb, &
&              res, resb)
      call popreal8array(mat12x12, 12**2)
      k_elemb = 0.0_8
      call matmul2_b(12, 12, 12, t_elem_t, t_elem_tb, k_elem, k_elemb, &
&              mat12x12, mat12x12b)
      call popreal8array(t_elem_t, 12**2)
      call transpose2_b(12, 12, t_elem, t_elemb, t_elem_t, t_elem_tb)
      resb = 0.0_8
      resb = k_elemb
      mat12x4b = 0.0_8
      pelem_zb = 0.0_8
      call matmul2_b(12, 4, 12, mat12x4, mat12x4b, pelem_z, pelem_zb, &
&              res, resb)
      call popreal8array(mat12x4, 12*4)
      pelem_z_tb = 0.0_8
      k_zb = 0.0_8
      call matmul2_b(12, 4, 4, pelem_z_t, pelem_z_tb, k_z, k_zb, mat12x4&
&              , mat12x4b)
      call popreal8array(pelem_z_t, 12*4)
      resb = 0.0_8
      resb = k_elemb
      mat12x4b = 0.0_8
      pelem_yb = 0.0_8
      call matmul2_b(12, 4, 12, mat12x4, mat12x4b, pelem_y, pelem_yb, &
&              res, resb)
      call popreal8array(mat12x4, 12*4)
      pelem_y_tb = 0.0_8
      k_yb = 0.0_8
      call matmul2_b(12, 4, 4, pelem_y_t, pelem_y_tb, k_y, k_yb, mat12x4&
&              , mat12x4b)
      call popreal8array(pelem_y_t, 12*4)
      resb = 0.0_8
      resb = k_elemb
      mat12x2b = 0.0_8
      pelem_tb = 0.0_8
      call matmul2_b(12, 2, 12, mat12x2, mat12x2b, pelem_t, pelem_tb, &
&              res, resb)
      gj_l = g*j(ielem)/l
      k_t(:, :) = gj_l*const2
      call popreal8array(mat12x2, 12*2)
      pelem_t_tb = 0.0_8
      k_tb = 0.0_8
      call matmul2_b(12, 2, 2, pelem_t_t, pelem_t_tb, k_t, k_tb, mat12x2&
&              , mat12x2b)
      call popreal8array(pelem_t_t, 12*2)
      resb = 0.0_8
      resb = k_elemb
      mat12x2b = 0.0_8
      pelem_ab = 0.0_8
      call matmul2_b(12, 2, 12, mat12x2, mat12x2b, pelem_a, pelem_ab, &
&              res, resb)
      ea_l = e*a(ielem)/l
      k_a(:, :) = ea_l*const2
      call popreal8array(mat12x2, 12*2)
      pelem_a_tb = 0.0_8
      k_ab = 0.0_8
      call matmul2_b(12, 2, 2, pelem_a_t, pelem_a_tb, k_a, k_ab, mat12x2&
&              , mat12x2b)
      call popreal8array(pelem_a_t, 12*2)
      call popreal8array(k_elem, 12**2)
      call popreal8array(k_z(:, 4), 4)
      lb = sum(k_z(:, 4)*k_zb(:, 4))
      k_zb(:, 4) = l*k_zb(:, 4)
      call popreal8array(k_z(:, 2), 4)
      lb = lb + sum(k_z(:, 2)*k_zb(:, 2))
      k_zb(:, 2) = l*k_zb(:, 2)
      call popreal8array(k_z(4, :), 4)
      lb = lb + sum(k_z(4, :)*k_zb(4, :))
      k_zb(4, :) = l*k_zb(4, :)
      call popreal8array(k_z(2, :), 4)
      lb = lb + sum(k_z(2, :)*k_zb(2, :))
      k_zb(2, :) = l*k_zb(2, :)
      call popreal8array(k_z, 4**2)
      eiz_l3b = sum(const_z*k_zb(:, :))
      call popreal8array(k_y(:, 4), 4)
      lb = lb + sum(k_y(:, 4)*k_yb(:, 4))
      k_yb(:, 4) = l*k_yb(:, 4)
      call popreal8array(k_y(:, 2), 4)
      lb = lb + sum(k_y(:, 2)*k_yb(:, 2))
      k_yb(:, 2) = l*k_yb(:, 2)
      call popreal8array(k_y(4, :), 4)
      lb = lb + sum(k_y(4, :)*k_yb(4, :))
      k_yb(4, :) = l*k_yb(4, :)
      call popreal8array(k_y(2, :), 4)
      lb = lb + sum(k_y(2, :)*k_yb(2, :))
      k_yb(2, :) = l*k_yb(2, :)
      call popreal8array(k_y, 4**2)
      eiy_l3b = sum(const_y*k_yb(:, :))
      gj_lb = sum(const2*k_tb(:, :))
      ea_lb = sum(const2*k_ab(:, :))
      temp0 = l**3
      tempb = e*eiz_l3b/temp0
      izb(ielem) = izb(ielem) + tempb
      temp = l**3
      tempb0 = e*eiy_l3b/temp
      iyb(ielem) = iyb(ielem) + tempb0
      tempb2 = g*gj_lb/l
      jb(ielem) = jb(ielem) + tempb2
      tempb1 = e*ea_lb/l
      lb = lb - iy(ielem)*3*l**2*tempb0/temp - a(ielem)*tempb1/l - j(&
&       ielem)*tempb2/l - iz(ielem)*3*l**2*tempb/temp0
      ab(ielem) = ab(ielem) + tempb1
      p0 = nodes(ielem, :)
      p1 = nodes(ielem+1, :)
      arg1(:) = p1 - p0
      call popreal8(l)
      arg1b = 0.0_8
      call norm_b(arg1(:), arg1b(:), l, lb)
      p0b = 0.0_8
      p1b = 0.0_8
      p1b = arg1b(:)
      p0b = -arg1b(:)
      do ind=4,1,-1
        call popreal8array(t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3&
&                    *(ind-1)+3), 3**2)
        tb = tb + t_elemb(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)&
&         +3)
        t_elemb(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = &
&         0.0_8
      end do
      z_locb = z_locb + tb(3, :)
      tb(3, :) = 0.0_8
      y_locb = y_locb + tb(2, :)
      tb(2, :) = 0.0_8
      x_locb = x_locb + tb(1, :)
      tb(1, :) = 0.0_8
      call unit_b(y_cross, y_crossb, z_loc, z_locb)
      call popreal8array(y_cross, 3)
      call cross_b(x_loc, x_locb, y_loc, y_locb, y_cross, y_crossb)
      call popreal8array(y_loc, 3)
      call unit_b(x_cross, x_crossb, y_loc, y_locb)
      call popreal8array(x_cross, 3)
      x_glb = 0.0_8
      call cross_b(x_loc, x_locb, x_gl, x_glb, x_cross, x_crossb)
      arg1(:) = p1 - p0
      call popreal8array(x_loc, 3)
      arg1b = 0.0_8
      call unit_b(arg1(:), arg1b(:), x_loc, x_locb)
      p1b = p1b + arg1b
      p0b = p0b - arg1b
      nodesb(ielem+1, :) = nodesb(ielem+1, :) + p1b
      nodesb(ielem, :) = nodesb(ielem, :) + p0b
    end do
    kb = 0.0_8
  end subroutine assemblestructmtx_main_b
  subroutine assemblestructmtx_main(n, tot_n_fem, nodes, a, j, iy, iz, &
&   k_a, k_t, k_y, k_z, cons, e, g, x_gl, t, k_elem, pelem_a, pelem_t, &
&   pelem_y, pelem_z, t_elem, const2, const_y, const_z, k)
    implicit none
! input
    integer, intent(in) :: n, cons, tot_n_fem
    real(kind=8), intent(in) :: nodes(tot_n_fem, 3), a(n-1), j(n-1), iy(&
&   n-1), iz(n-1)
    real(kind=8), intent(in) :: e, g, x_gl(3)
    real(kind=8), intent(inout) :: k_a(2, 2), k_t(2, 2), k_y(4, 4), k_z(&
&   4, 4)
    real(kind=8), intent(inout) :: t(3, 3), k_elem(12, 12), t_elem(12, &
&   12)
    real(kind=8), intent(in) :: pelem_a(2, 12), pelem_t(2, 12), pelem_y(&
&   4, 12), pelem_z(4, 12)
    real(kind=8), intent(in) :: const2(2, 2), const_y(4, 4), const_z(4, &
&   4)
! output
    real(kind=8), intent(out) :: k(6*n+6, 6*n+6)
! working
    real(kind=8) :: p0(3), p1(3), x_loc(3), y_loc(3), z_loc(3), x_cross(&
&   3), y_cross(3)
    real(kind=8) :: l, ea_l, gj_l, eiy_l3, eiz_l3, res(12, 12)
    real(kind=8) :: mat12x12(12, 12), mat12x4(12, 4), mat12x2(12, 2)
    integer :: num_elems, num_nodes, num_cons, ielem, in0, in1, ind, i
    real(kind=8) :: pelem_a_t(12, 2), pelem_t_t(12, 2), k_(6*n+6, 6*n+6)
    real(kind=8) :: pelem_y_t(12, 4), pelem_z_t(12, 4), t_elem_t(12, 12)
    real(kind=8), dimension(3) :: arg1
    num_elems = n - 1
    num_nodes = n
! only 1 con in current spatialbeam code
    num_cons = 1
    k(:, :) = 0.
! loop over num elements
    do ielem=1,num_elems
      p0 = nodes(ielem, :)
      p1 = nodes(ielem+1, :)
      arg1(:) = p1 - p0
      call unit(arg1(:), x_loc)
      call cross(x_loc, x_gl, x_cross)
      call unit(x_cross, y_loc)
      call cross(x_loc, y_loc, y_cross)
      call unit(y_cross, z_loc)
      t(1, :) = x_loc
      t(2, :) = y_loc
      t(3, :) = z_loc
      do ind=1,4
        t_elem(3*(ind-1)+1:3*(ind-1)+3, 3*(ind-1)+1:3*(ind-1)+3) = t
      end do
      arg1(:) = p1 - p0
      call norm(arg1(:), l)
      ea_l = e*a(ielem)/l
      gj_l = g*j(ielem)/l
      eiy_l3 = e*iy(ielem)/l**3
      eiz_l3 = e*iz(ielem)/l**3
      k_a(:, :) = ea_l*const2
      k_t(:, :) = gj_l*const2
      k_y(:, :) = eiy_l3*const_y
      k_y(2, :) = k_y(2, :)*l
      k_y(4, :) = k_y(4, :)*l
      k_y(:, 2) = k_y(:, 2)*l
      k_y(:, 4) = k_y(:, 4)*l
      k_z(:, :) = eiz_l3*const_z
      k_z(2, :) = k_z(2, :)*l
      k_z(4, :) = k_z(4, :)*l
      k_z(:, 2) = k_z(:, 2)*l
      k_z(:, 4) = k_z(:, 4)*l
      k_elem(:, :) = 0.
      call transpose2(2, 12, pelem_a, pelem_a_t)
      call matmul2(12, 2, 2, pelem_a_t, k_a, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_a, res)
      k_elem = k_elem + res
      call transpose2(2, 12, pelem_t, pelem_t_t)
      call matmul2(12, 2, 2, pelem_t_t, k_t, mat12x2)
      call matmul2(12, 2, 12, mat12x2, pelem_t, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_y, pelem_y_t)
      call matmul2(12, 4, 4, pelem_y_t, k_y, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_y, res)
      k_elem = k_elem + res
      call transpose2(4, 12, pelem_z, pelem_z_t)
      call matmul2(12, 4, 4, pelem_z_t, k_z, mat12x4)
      call matmul2(12, 4, 12, mat12x4, pelem_z, res)
      k_elem = k_elem + res
      call transpose2(12, 12, t_elem, t_elem_t)
      call matmul2(12, 12, 12, t_elem_t, k_elem, mat12x12)
      call matmul2(12, 12, 12, mat12x12, t_elem, res)
      in0 = ielem
      in1 = ielem + 1
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(:6, :6)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in0-1)+1:6*(in0-1)+6) + res(7:, :6)
      k(6*(in0-1)+1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in0-1)+&
&       1:6*(in0-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(:6, 7:)
      k(6*(in1-1)+1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) = k(6*(in1-1)+&
&       1:6*(in1-1)+6, 6*(in1-1)+1:6*(in1-1)+6) + res(7:, 7:)
    end do
    do i=1,6
      k(6*num_nodes+i, 6*cons+i) = 10**9.
      k(6*cons+i, 6*num_nodes+i) = 10**9.
    end do
  end subroutine assemblestructmtx_main
!  differentiation of transpose2 in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: new_mtx mtx
!   with respect to varying inputs: new_mtx mtx
  subroutine transpose2_b(m, n, mtx, mtxb, new_mtx, new_mtxb)
    implicit none
    integer, intent(in) :: m, n
    real(kind=8), intent(in) :: mtx(m, n)
    real(kind=8) :: mtxb(m, n)
    real(kind=8) :: new_mtx(n, m)
    real(kind=8) :: new_mtxb(n, m)
    integer :: i, j
    do i=m,1,-1
      do j=n,1,-1
        mtxb(i, j) = mtxb(i, j) + new_mtxb(j, i)
        new_mtxb(j, i) = 0.0_8
      end do
    end do
  end subroutine transpose2_b
  subroutine transpose2(m, n, mtx, new_mtx)
    implicit none
    integer, intent(in) :: m, n
    real(kind=8), intent(in) :: mtx(m, n)
    real(kind=8), intent(out) :: new_mtx(n, m)
    integer :: i, j
    do i=1,m
      do j=1,n
        new_mtx(j, i) = mtx(i, j)
      end do
    end do
  end subroutine transpose2
!  differentiation of matmul2 in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b
  subroutine matmul2_b(m, n, p, a, ab, b, bb, c, cb)
    implicit none
    integer, intent(in) :: m, n, p
    real(kind=8), intent(in) :: a(m, n), b(n, p)
    real(kind=8) :: ab(m, n), bb(n, p)
    real(kind=8) :: c(m, p)
    real(kind=8) :: cb(m, p)
    integer :: i, j, k
    do i=m,1,-1
      do j=p,1,-1
        do k=n,1,-1
          ab(i, k) = ab(i, k) + b(k, j)*cb(i, j)
          bb(k, j) = bb(k, j) + a(i, k)*cb(i, j)
        end do
      end do
    end do
  end subroutine matmul2_b
  subroutine matmul2(m, n, p, a, b, c)
    implicit none
    integer, intent(in) :: m, n, p
    real(kind=8), intent(in) :: a(m, n), b(n, p)
    real(kind=8), intent(out) :: c(m, p)
    integer :: i, j, k
    c(:, :) = 0.
    do i=1,m
      do j=1,p
        do k=1,n
          c(i, j) = c(i, j) + a(i, k)*b(k, j)
        end do
      end do
    end do
  end subroutine matmul2
!  differentiation of assembleaeromtx_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: mtx
!   with respect to varying inputs: alpha points mesh bpts mtx
!   rw status of diff variables: alpha:out points:out mesh:out
!                bpts:out mtx:in-zero
  subroutine assembleaeromtx_main_b(ny, nx, ny_, nx_, alpha, alphab, &
&   points, pointsb, bpts, bptsb, mesh, meshb, skip, symmetry, mtx, mtxb&
& )
    implicit none
! input
    integer, intent(in) :: ny, nx, ny_, nx_
    real(kind=8), intent(in) :: alpha, mesh(nx_, ny_, 3)
    real(kind=8) :: alphab, meshb(nx_, ny_, 3)
    real(kind=8), intent(in) :: points(nx-1, ny-1, 3), bpts(nx_-1, ny_, &
&   3)
    real(kind=8) :: pointsb(nx-1, ny-1, 3), bptsb(nx_-1, ny_, 3)
    logical, intent(in) :: skip, symmetry
! output
    real(kind=8) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
    real(kind=8) :: mtxb((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
! working
    integer :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    real(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    real(kind=8) :: pb(3), ab(3), bb(3), ub(3), cb(3), db(3)
    real(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    real(kind=8) :: a_symb(3), b_symb(3), c_symb(3), d_symb(3)
    real(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    real(kind=8) :: ur2b(3), r1b(3), r2b(3), r1_magb, r2_magb
    real(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    real(kind=8) :: ur1b(3), boundb(3), dot_ur2b, dot_ur1b
    real(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym(3)
    real(kind=8) :: edgesb(3), c_teb(3), d_teb(3), c_te_symb(3), &
&   d_te_symb(3)
    intrinsic atan
    intrinsic cos
    intrinsic sin
    integer :: branch
    real(kind=8) :: tempb6
    real(kind=8) :: tempb5(3)
    real(kind=8) :: tempb4
    real(kind=8) :: tempb3(3)
    real(kind=8) :: tempb2
    real(kind=8) :: tempb1(3)
    real(kind=8) :: tempb0
    real(kind=8) :: tempb(3)
    pi = 4.d0*atan(1.d0)
! trailing vortices in avl follow the x-axis; no cos or sin
! u(1) = 1.
! u(3) = 0.
    u(1) = cos(alpha*pi/180.)
    u(2) = 0.
    u(3) = sin(alpha*pi/180.)
! spanwise loop through horseshoe elements
    do el_j=1,ny_-1
      call pushinteger4(el_loc_j)
      el_loc_j = (el_j-1)*(nx_-1)
      call pushreal8array(c_te, 3)
      c_te = mesh(nx_, el_j+1, :)
      call pushreal8array(d_te, 3)
      d_te = mesh(nx_, el_j+0, :)
      if (symmetry) then
        c_te_sym = c_te
        d_te_sym = d_te
        c_te_sym(2) = -c_te_sym(2)
        d_te_sym(2) = -d_te_sym(2)
        call pushcontrol1b(1)
      else
        call pushcontrol1b(0)
      end if
! spanwise loop through control points
      do cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        do cp_i=1,nx-1
          call pushinteger4(cp_loc)
          cp_loc = cp_i + cp_loc_j
          call pushreal8array(p, 3)
          p = points(cp_i, cp_j, :)
          call pushreal8array(r1, 3)
          r1 = p - d_te
          call pushreal8array(r2, 3)
          r2 = p - c_te
          call pushreal8(r1_mag)
          call norm(r1, r1_mag)
          call pushreal8(r2_mag)
          call norm(r2, r2_mag)
          call pushreal8array(ur2, 3)
          call cross(u, r2, ur2)
          call pushreal8array(ur1, 3)
          call cross(u, r1, ur1)
          call pushreal8(dot_ur2)
          call dot(u, r2, dot_ur2)
          call pushreal8(dot_ur1)
          call dot(u, r1, dot_ur1)
          if (symmetry) then
            r1 = p - d_te_sym
            r2 = p - c_te_sym
            call pushreal8(r1_mag)
            call norm(r1, r1_mag)
            call pushreal8(r2_mag)
            call norm(r2, r2_mag)
            call pushreal8array(ur2, 3)
            call cross(u, r2, ur2)
            call pushreal8array(ur1, 3)
            call cross(u, r1, ur1)
            call pushreal8(dot_ur2)
            call dot(u, r2, dot_ur2)
            call pushreal8(dot_ur1)
            call dot(u, r1, dot_ur1)
            call pushcontrol1b(1)
          else
            call pushcontrol1b(0)
          end if
! chordwise loop through horseshoe elements
          do el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            call pushreal8array(a, 3)
            a = bpts(el_i+0, el_j+0, :)
            call pushreal8array(b, 3)
            b = bpts(el_i+0, el_j+1, :)
            if (el_i .eq. nx_ - 1) then
              call pushreal8array(c, 3)
              c = c_te
              call pushreal8array(d, 3)
              d = d_te
              call pushcontrol1b(0)
            else
              call pushreal8array(c, 3)
              c = bpts(el_i+1, el_j+1, :)
              call pushreal8array(d, 3)
              d = bpts(el_i+1, el_j+0, :)
              call pushcontrol1b(1)
            end if
            if (symmetry) then
              call pushreal8array(a_sym, 3)
              a_sym = a
              call pushreal8array(b_sym, 3)
              b_sym = b
              call pushreal8array(c_sym, 3)
              c_sym = c
              call pushreal8array(d_sym, 3)
              d_sym = d
              a_sym(2) = -a_sym(2)
              b_sym(2) = -b_sym(2)
              c_sym(2) = -c_sym(2)
              d_sym(2) = -d_sym(2)
              call pushcontrol1b(0)
            else
              call pushcontrol1b(1)
            end if
            if (.not.(skip .and. cp_loc .eq. el_loc)) then
              call pushcontrol1b(0)
            else
              call pushcontrol1b(1)
            end if
          end do
        end do
      end do
    end do
    pointsb = 0.0_8
    meshb = 0.0_8
    bptsb = 0.0_8
    ub = 0.0_8
    ur1b = 0.0_8
    ur2b = 0.0_8
    c_te_symb = 0.0_8
    d_te_symb = 0.0_8
    do el_j=ny_-1,1,-1
      c_teb = 0.0_8
      d_teb = 0.0_8
      do cp_j=ny-1,1,-1
        do cp_i=nx-1,1,-1
          pb = 0.0_8
          edgesb = 0.0_8
          do el_i=1,nx_-1,1
            el_loc = el_i + el_loc_j
            boundb = 0.0_8
            edgesb = edgesb + mtxb(cp_loc, el_loc, :)
            boundb = mtxb(cp_loc, el_loc, :)
            mtxb(cp_loc, el_loc, :) = 0.0_8
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              a = bpts(el_i+0, el_j+0, :)
              b = bpts(el_i+0, el_j+1, :)
              ab = 0.0_8
              bb = 0.0_8
              call calc_vorticity_b(a, ab, b, bb, p, pb, bound, boundb)
            else
              ab = 0.0_8
              bb = 0.0_8
            end if
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              b_symb = 0.0_8
              a_symb = 0.0_8
              call calc_vorticity_b(b_sym, b_symb, a_sym, a_symb, p, pb&
&                             , bound, boundb)
              d_symb = 0.0_8
              call calc_vorticity_b(a_sym, a_symb, d_sym, d_symb, p, pb&
&                             , edges, edgesb)
              c_symb = 0.0_8
              call calc_vorticity_b(c_sym, c_symb, b_sym, b_symb, p, pb&
&                             , edges, edgesb)
              d_symb(2) = -d_symb(2)
              c_symb(2) = -c_symb(2)
              b_symb(2) = -b_symb(2)
              a_symb(2) = -a_symb(2)
              db = 0.0_8
              call popreal8array(d_sym, 3)
              db = d_symb
              cb = 0.0_8
              call popreal8array(c_sym, 3)
              cb = c_symb
              call popreal8array(b_sym, 3)
              bb = bb + b_symb
              call popreal8array(a_sym, 3)
              ab = ab + a_symb
            else
              db = 0.0_8
              cb = 0.0_8
            end if
            call calc_vorticity_b(d, db, a, ab, p, pb, edges, edgesb)
            call calc_vorticity_b(b, bb, c, cb, p, pb, edges, edgesb)
            call popcontrol1b(branch)
            if (branch .eq. 0) then
              call popreal8array(d, 3)
              d_teb = d_teb + db
              call popreal8array(c, 3)
              c_teb = c_teb + cb
            else
              call popreal8array(d, 3)
              bptsb(el_i+1, el_j+0, :) = bptsb(el_i+1, el_j+0, :) + db
              call popreal8array(c, 3)
              bptsb(el_i+1, el_j+1, :) = bptsb(el_i+1, el_j+1, :) + cb
            end if
            call popreal8array(b, 3)
            bptsb(el_i+0, el_j+1, :) = bptsb(el_i+0, el_j+1, :) + bb
            call popreal8array(a, 3)
            bptsb(el_i+0, el_j+0, :) = bptsb(el_i+0, el_j+0, :) + ab
          end do
          call popcontrol1b(branch)
          if (branch .ne. 0) then
            tempb3 = edgesb/(r1_mag*(r1_mag-dot_ur1))
            tempb4 = sum(-(ur1*tempb3/(r1_mag*(r1_mag-dot_ur1))))
            ur1b = ur1b + tempb3
            r1_magb = (2*r1_mag-dot_ur1)*tempb4
            dot_ur1b = -(r1_mag*tempb4)
            tempb5 = -(edgesb/(r2_mag*(r2_mag-dot_ur2)))
            tempb6 = sum(-(ur2*tempb5/(r2_mag*(r2_mag-dot_ur2))))
            ur2b = ur2b + tempb5
            r2_magb = (2*r2_mag-dot_ur2)*tempb6
            dot_ur2b = -(r2_mag*tempb6)
            call popreal8(dot_ur1)
            call dot_b(u, ub, r1, r1b, dot_ur1, dot_ur1b)
            call popreal8(dot_ur2)
            call dot_b(u, ub, r2, r2b, dot_ur2, dot_ur2b)
            call popreal8array(ur1, 3)
            call cross_b(u, ub, r1, r1b, ur1, ur1b)
            call popreal8array(ur2, 3)
            call cross_b(u, ub, r2, r2b, ur2, ur2b)
            call popreal8(r2_mag)
            call norm_b(r2, r2b, r2_mag, r2_magb)
            call popreal8(r1_mag)
            call norm_b(r1, r1b, r1_mag, r1_magb)
            pb = pb + r1b + r2b
            c_te_symb = c_te_symb - r2b
            d_te_symb = d_te_symb - r1b
          end if
          tempb = -(edgesb/(r1_mag*(r1_mag-dot_ur1)))
          tempb0 = sum(-(ur1*tempb/(r1_mag*(r1_mag-dot_ur1))))
          ur1b = ur1b + tempb
          r1_magb = (2*r1_mag-dot_ur1)*tempb0
          dot_ur1b = -(r1_mag*tempb0)
          tempb1 = edgesb/(r2_mag*(r2_mag-dot_ur2))
          tempb2 = sum(-(ur2*tempb1/(r2_mag*(r2_mag-dot_ur2))))
          ur2b = ur2b + tempb1
          r2_magb = (2*r2_mag-dot_ur2)*tempb2
          dot_ur2b = -(r2_mag*tempb2)
          r1 = p - d_te
          call popreal8(dot_ur1)
          call dot_b(u, ub, r1, r1b, dot_ur1, dot_ur1b)
          r2 = p - c_te
          call popreal8(dot_ur2)
          call dot_b(u, ub, r2, r2b, dot_ur2, dot_ur2b)
          call popreal8array(ur1, 3)
          call cross_b(u, ub, r1, r1b, ur1, ur1b)
          call popreal8array(ur2, 3)
          call cross_b(u, ub, r2, r2b, ur2, ur2b)
          call popreal8(r2_mag)
          call norm_b(r2, r2b, r2_mag, r2_magb)
          call popreal8(r1_mag)
          call norm_b(r1, r1b, r1_mag, r1_magb)
          call popreal8array(r2, 3)
          pb = pb + r1b + r2b
          c_teb = c_teb - r2b
          call popreal8array(r1, 3)
          d_teb = d_teb - r1b
          call popreal8array(p, 3)
          pointsb(cp_i, cp_j, :) = pointsb(cp_i, cp_j, :) + pb
          call popinteger4(cp_loc)
        end do
      end do
      call popcontrol1b(branch)
      if (branch .ne. 0) then
        d_te_symb(2) = -d_te_symb(2)
        c_te_symb(2) = -c_te_symb(2)
        d_teb = d_teb + d_te_symb
        c_teb = c_teb + c_te_symb
        c_te_symb = 0.0_8
        d_te_symb = 0.0_8
      end if
      call popreal8array(d_te, 3)
      meshb(nx_, el_j+0, :) = meshb(nx_, el_j+0, :) + d_teb
      call popreal8array(c_te, 3)
      meshb(nx_, el_j+1, :) = meshb(nx_, el_j+1, :) + c_teb
      call popinteger4(el_loc_j)
    end do
    alphab = pi*cos(pi*(alpha/180.))*ub(3)/180.
    ub(3) = 0.0_8
    ub(2) = 0.0_8
    alphab = alphab - pi*sin(pi*(alpha/180.))*ub(1)/180.
    mtxb = 0.0_8
  end subroutine assembleaeromtx_main_b
  subroutine assembleaeromtx_main(ny, nx, ny_, nx_, alpha, points, bpts&
&   , mesh, skip, symmetry, mtx)
    implicit none
! input
    integer, intent(in) :: ny, nx, ny_, nx_
    real(kind=8), intent(in) :: alpha, mesh(nx_, ny_, 3)
    real(kind=8), intent(in) :: points(nx-1, ny-1, 3), bpts(nx_-1, ny_, &
&   3)
    logical, intent(in) :: skip, symmetry
! output
    real(kind=8), intent(out) :: mtx((nx-1)*(ny-1), (nx_-1)*(ny_-1), 3)
! working
    integer :: el_j, el_i, cp_j, cp_i, el_loc_j, el_loc, cp_loc_j, &
&   cp_loc
    real(kind=8) :: pi, p(3), a(3), b(3), u(3), c(3), d(3)
    real(kind=8) :: a_sym(3), b_sym(3), c_sym(3), d_sym(3)
    real(kind=8) :: ur2(3), r1(3), r2(3), r1_mag, r2_mag
    real(kind=8) :: ur1(3), bound(3), dot_ur2, dot_ur1
    real(kind=8) :: edges(3), c_te(3), d_te(3), c_te_sym(3), d_te_sym(3)
    intrinsic atan
    intrinsic cos
    intrinsic sin
    pi = 4.d0*atan(1.d0)
! trailing vortices in avl follow the x-axis; no cos or sin
! u(1) = 1.
! u(3) = 0.
    u(1) = cos(alpha*pi/180.)
    u(2) = 0.
    u(3) = sin(alpha*pi/180.)
    mtx(:, :, :) = 0.
! spanwise loop through horseshoe elements
    do el_j=1,ny_-1
      el_loc_j = (el_j-1)*(nx_-1)
      c_te = mesh(nx_, el_j+1, :)
      d_te = mesh(nx_, el_j+0, :)
      if (symmetry) then
        c_te_sym = c_te
        d_te_sym = d_te
        c_te_sym(2) = -c_te_sym(2)
        d_te_sym(2) = -d_te_sym(2)
      end if
! spanwise loop through control points
      do cp_j=1,ny-1
        cp_loc_j = (cp_j-1)*(nx-1)
! chordwise loop through control points
        do cp_i=1,nx-1
          cp_loc = cp_i + cp_loc_j
          p = points(cp_i, cp_j, :)
          r1 = p - d_te
          r2 = p - c_te
          call norm(r1, r1_mag)
          call norm(r2, r2_mag)
          call cross(u, r2, ur2)
          call cross(u, r1, ur1)
          edges(:) = 0.
          call dot(u, r2, dot_ur2)
          call dot(u, r1, dot_ur1)
          edges = ur2/(r2_mag*(r2_mag-dot_ur2))
          edges = edges - ur1/(r1_mag*(r1_mag-dot_ur1))
          if (symmetry) then
            r1 = p - d_te_sym
            r2 = p - c_te_sym
            call norm(r1, r1_mag)
            call norm(r2, r2_mag)
            call cross(u, r2, ur2)
            call cross(u, r1, ur1)
            call dot(u, r2, dot_ur2)
            call dot(u, r1, dot_ur1)
            edges = edges - ur2/(r2_mag*(r2_mag-dot_ur2))
            edges = edges + ur1/(r1_mag*(r1_mag-dot_ur1))
          end if
! chordwise loop through horseshoe elements
          do el_i=nx_-1,1,-1
            el_loc = el_i + el_loc_j
            a = bpts(el_i+0, el_j+0, :)
            b = bpts(el_i+0, el_j+1, :)
            if (el_i .eq. nx_ - 1) then
              c = c_te
              d = d_te
            else
              c = bpts(el_i+1, el_j+1, :)
              d = bpts(el_i+1, el_j+0, :)
            end if
            call calc_vorticity(b, c, p, edges)
            call calc_vorticity(d, a, p, edges)
            bound(:) = 0.
            if (symmetry) then
              a_sym = a
              b_sym = b
              c_sym = c
              d_sym = d
              a_sym(2) = -a_sym(2)
              b_sym(2) = -b_sym(2)
              c_sym(2) = -c_sym(2)
              d_sym(2) = -d_sym(2)
              call calc_vorticity(c_sym, b_sym, p, edges)
              call calc_vorticity(a_sym, d_sym, p, edges)
              call calc_vorticity(b_sym, a_sym, p, bound)
            end if
            if (.not.(skip .and. cp_loc .eq. el_loc)) call &
&             calc_vorticity(a, b, p, bound)
            mtx(cp_loc, el_loc, :) = edges + bound
          end do
        end do
      end do
    end do
  end subroutine assembleaeromtx_main
!  differentiation of calc_vorticity in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: p out a b
!   with respect to varying inputs: p out a b
  subroutine calc_vorticity_b(a, ab, b, bb, p, pb, out, outb)
    implicit none
! input
    real(kind=8), intent(in) :: a(3), b(3), p(3)
    real(kind=8) :: ab(3), bb(3), pb(3)
! output
    real(kind=8), intent(inout) :: out(3)
    real(kind=8) :: outb(3)
! working
    real(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    real(kind=8) :: r1b(3), r2b(3), r1_magb, r2_magb, r1r2b(3), &
&   mag_multb, dot_r1r2b
    real(kind=8) :: tempb0
    real(kind=8) :: tempb(3)
    r1 = p - a
    r2 = p - b
    call norm(r1, r1_mag)
    call norm(r2, r2_mag)
    call cross(r1, r2, r1r2)
    mag_mult = r1_mag*r2_mag
    call dot(r1, r2, dot_r1r2)
    r1r2b = 0.0_8
    tempb = outb/(mag_mult*(mag_mult+dot_r1r2))
    tempb0 = sum(-((r1_mag+r2_mag)*r1r2*tempb/(mag_mult*(mag_mult+&
&     dot_r1r2))))
    r1r2b = (r1_mag+r2_mag)*tempb
    mag_multb = (2*mag_mult+dot_r1r2)*tempb0
    r1_magb = r2_mag*mag_multb + sum(r1r2*tempb)
    r2_magb = r1_mag*mag_multb + sum(r1r2*tempb)
    dot_r1r2b = mag_mult*tempb0
    r1b = 0.0_8
    call dot_b(r1, r1b, r2, r2b, dot_r1r2, dot_r1r2b)
    call cross_b(r1, r1b, r2, r2b, r1r2, r1r2b)
    call norm_b(r2, r2b, r2_mag, r2_magb)
    call norm_b(r1, r1b, r1_mag, r1_magb)
    pb = pb + r1b + r2b
    bb = bb - r2b
    ab = ab - r1b
  end subroutine calc_vorticity_b
  subroutine calc_vorticity(a, b, p, out)
    implicit none
! input
    real(kind=8), intent(in) :: a(3), b(3), p(3)
! output
    real(kind=8), intent(inout) :: out(3)
! working
    real(kind=8) :: r1(3), r2(3), r1_mag, r2_mag, r1r2(3), mag_mult, &
&   dot_r1r2
    r1 = p - a
    r2 = p - b
    call norm(r1, r1_mag)
    call norm(r2, r2_mag)
    call cross(r1, r2, r1r2)
    mag_mult = r1_mag*r2_mag
    call dot(r1, r2, dot_r1r2)
    out = out + (r1_mag+r2_mag)*r1r2/(mag_mult*(mag_mult+dot_r1r2))
  end subroutine calc_vorticity
  subroutine biotsavart(a, b, p, inf, rev, out)
    implicit none
! input
    real(kind=8), intent(in) :: a(3), b(3), p(3)
    logical, intent(in) :: inf, rev
! output
    real(kind=8), intent(inout) :: out(3)
! working
    real(kind=8) :: rpa, rpb, rab, rh
    real(kind=8) :: cosa, cosb, c(3)
    real(kind=8) :: eps, tmp(3), dot_bapa, dot_baba, dot_pbab
    real(kind=8), dimension(3) :: arg1
    real(kind=8), dimension(3) :: arg2
    eps = 1e-5
    arg1(:) = a - p
    call norm(arg1(:), rpa)
    arg1(:) = b - p
    call norm(arg1(:), rpb)
    arg1(:) = b - a
    call norm(arg1(:), rab)
    arg1(:) = b - a
    arg2(:) = p - a
    call dot(arg1(:), arg2(:), dot_bapa)
    arg1(:) = b - a
    arg2(:) = b - a
    call dot(arg1(:), arg2(:), dot_baba)
    arg1(:) = p - b
    arg2(:) = a - b
    call dot(arg1(:), arg2(:), dot_pbab)
    arg1(:) = p - a - dot_bapa/dot_baba*(b-a)
    call norm(arg1(:), rh)
    rh = rh + eps
    cosa = dot_bapa/(rpa*rab)
    cosb = dot_pbab/(rpb*rab)
    arg1(:) = b - p
    arg2(:) = a - p
    call cross(arg1(:), arg2(:), c)
    call unit(c, c)
    if (inf) then
      tmp = -(c/rh*(cosa+1))
    else
      tmp = -(c/rh*(cosa+cosb))
    end if
    if (rev) tmp = -tmp
    out = out + tmp
  end subroutine biotsavart
!  differentiation of forcecalc_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: sec_forces
!   with respect to varying inputs: v circ bpts sec_forces rho
!   rw status of diff variables: v:out circ:out bpts:out sec_forces:in-out
!                rho:out
  subroutine forcecalc_main_b(v, vb, circ, circb, rho, rhob, bpts, bptsb&
&   , nx, ny, num_panels, sec_forces, sec_forcesb)
    implicit none
    integer, intent(in) :: nx, ny, num_panels
    real(kind=8), intent(in) :: v(num_panels, 3), circ(num_panels), rho&
&   , bpts(nx-1, ny, 3)
    real(kind=8) :: vb(num_panels, 3), circb(num_panels), rhob, bptsb(nx&
&   -1, ny, 3)
    real(kind=8) :: sec_forces(num_panels, 3)
    real(kind=8) :: sec_forcesb(num_panels, 3)
    real(kind=8) :: bound(num_panels, 3), v_cross_bound(num_panels, 3), &
&   tmp(3)
    real(kind=8) :: boundb(num_panels, 3), v_cross_boundb(num_panels, 3)&
&   , tmpb(3)
    integer :: i, j, k
    real(kind=8) :: tempb(num_panels)
    do j=1,ny-1
      do i=1,nx-1
        bound((j-1)*(nx-1)+i, :) = bpts(i, j+1, :) - bpts(i, j, :)
      end do
    end do
    do i=1,num_panels
      call cross(v(i, :), bound(i, :), tmp)
      v_cross_bound(i, :) = tmp
    end do
    circb = 0.0_8
    rhob = 0.0_8
    v_cross_boundb = 0.0_8
    do i=3,1,-1
      tempb = v_cross_bound(:, i)*sec_forcesb(:, i)
      rhob = rhob + sum(circ*tempb)
      circb = circb + rho*tempb
      v_cross_boundb(:, i) = v_cross_boundb(:, i) + rho*circ*sec_forcesb&
&       (:, i)
      sec_forcesb(:, i) = 0.0_8
    end do
    vb = 0.0_8
    boundb = 0.0_8
    tmpb = 0.0_8
    do i=num_panels,1,-1
      tmpb = tmpb + v_cross_boundb(i, :)
      v_cross_boundb(i, :) = 0.0_8
      call cross_b(v(i, :), vb(i, :), bound(i, :), boundb(i, :), tmp, &
&            tmpb)
    end do
    bptsb = 0.0_8
    do j=ny-1,1,-1
      do i=nx-1,1,-1
        bptsb(i, j+1, :) = bptsb(i, j+1, :) + boundb((j-1)*(nx-1)+i, :)
        bptsb(i, j, :) = bptsb(i, j, :) - boundb((j-1)*(nx-1)+i, :)
        boundb((j-1)*(nx-1)+i, :) = 0.0_8
      end do
    end do
  end subroutine forcecalc_main_b
  subroutine forcecalc_main(v, circ, rho, bpts, nx, ny, num_panels, &
&   sec_forces)
    implicit none
    integer, intent(in) :: nx, ny, num_panels
    real(kind=8), intent(in) :: v(num_panels, 3), circ(num_panels), rho&
&   , bpts(nx-1, ny, 3)
    real(kind=8), intent(out) :: sec_forces(num_panels, 3)
    real(kind=8) :: bound(num_panels, 3), v_cross_bound(num_panels, 3), &
&   tmp(3)
    integer :: i, j, k
    do j=1,ny-1
      do i=1,nx-1
        bound((j-1)*(nx-1)+i, :) = bpts(i, j+1, :) - bpts(i, j, :)
      end do
    end do
    do i=1,num_panels
      call cross(v(i, :), bound(i, :), tmp)
      v_cross_bound(i, :) = tmp
    end do
    do i=1,3
      sec_forces(:, i) = rho*circ*v_cross_bound(:, i)
    end do
  end subroutine forcecalc_main
!  differentiation of momentcalc_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: m
!   with respect to varying inputs: chords m s_ref bpts sec_forces
!                cg widths
!   rw status of diff variables: chords:out m:in-zero s_ref:out
!                bpts:out sec_forces:out cg:out widths:out
  subroutine momentcalc_main_b(bpts, bptsb, cg, cgb, chords, chordsb, &
&   widths, widthsb, s_ref, s_refb, sec_forces, sec_forcesb, symmetry, &
&   nx, ny, m, mb)
    implicit none
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: bpts(nx-1, ny, 3)
    real(kind=8) :: bptsb(nx-1, ny, 3)
    real(kind=8), intent(in) :: cg(3), s_ref
    real(kind=8) :: cgb(3), s_refb
    real(kind=8), intent(in) :: chords(ny), widths(ny-1)
    real(kind=8) :: chordsb(ny), widthsb(ny-1)
    logical, intent(in) :: symmetry
    real(kind=8), intent(in) :: sec_forces(nx-1, ny-1, 3)
    real(kind=8) :: sec_forcesb(nx-1, ny-1, 3)
    real(kind=8) :: m(3)
    real(kind=8) :: mb(3)
    real(kind=8) :: panel_chords(ny-1), mac, moment(ny-1, 3), tmp(3)
    real(kind=8) :: panel_chordsb(ny-1), macb, momentb(ny-1, 3), tmpb(3)
    integer :: i, j, k
    intrinsic sum
    real*8, dimension(3) :: arg1
    real*8, dimension(3) :: arg1b
    integer :: branch
    real(kind=8) :: tempb
    panel_chords = (chords(2:)+chords(:ny-1))/2.
    mac = 1./s_ref*sum(panel_chords**2*widths)
    if (symmetry) then
      mac = mac*2
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    moment(:, :) = 0.
    do j=1,ny-1
      do i=1,nx-1
        arg1(:) = (bpts(i, j+1, :)+bpts(i, j, :))/2. - cg
        call cross(arg1(:), sec_forces(i, j, :), tmp)
        moment(j, :) = moment(j, :) + tmp
      end do
    end do
    if (symmetry) then
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
    end if
    momentb = 0.0_8
    do j=ny-1,1,-1
      momentb(j, :) = momentb(j, :) + mb
    end do
    call popcontrol1b(branch)
    if (branch .eq. 0) then
      momentb(:, 3) = 0.0_8
      momentb(:, 2) = 2*momentb(:, 2)
      momentb(:, 1) = 0.0_8
    end if
    macb = sum(-(moment*momentb/mac))/mac
    momentb = momentb/mac
    bptsb = 0.0_8
    sec_forcesb = 0.0_8
    cgb = 0.0_8
    tmpb = 0.0_8
    do j=ny-1,1,-1
      do i=nx-1,1,-1
        tmpb = tmpb + momentb(j, :)
        arg1(:) = (bpts(i, j+1, :)+bpts(i, j, :))/2. - cg
        arg1b = 0.0_8
        call cross_b(arg1(:), arg1b(:), sec_forces(i, j, :), sec_forcesb&
&              (i, j, :), tmp, tmpb)
        bptsb(i, j+1, :) = bptsb(i, j+1, :) + arg1b/2.
        bptsb(i, j, :) = bptsb(i, j, :) + arg1b/2.
        cgb = cgb - arg1b
      end do
    end do
    call popcontrol1b(branch)
    if (branch .eq. 0) macb = 2*macb
    widthsb = 0.0_8
    panel_chordsb = 0.0_8
    tempb = macb/s_ref
    panel_chordsb = 2*panel_chords*widths*tempb
    widthsb = panel_chords**2*tempb
    s_refb = -(sum(panel_chords**2*widths)*tempb/s_ref)
    chordsb = 0.0_8
    chordsb(2:ny) = chordsb(2:ny) + panel_chordsb/2.
    chordsb(1:ny-1) = chordsb(1:ny-1) + panel_chordsb/2.
    mb = 0.0_8
  end subroutine momentcalc_main_b
  subroutine momentcalc_main(bpts, cg, chords, widths, s_ref, sec_forces&
&   , symmetry, nx, ny, m)
    implicit none
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: bpts(nx-1, ny, 3)
    real(kind=8), intent(in) :: cg(3), s_ref
    real(kind=8), intent(in) :: chords(ny), widths(ny-1)
    logical, intent(in) :: symmetry
    real(kind=8), intent(in) :: sec_forces(nx-1, ny-1, 3)
    real(kind=8), intent(out) :: m(3)
    real(kind=8) :: panel_chords(ny-1), mac, moment(ny-1, 3), tmp(3)
    integer :: i, j, k
    intrinsic sum
    real*8, dimension(3) :: arg1
    panel_chords = (chords(2:)+chords(:ny-1))/2.
    mac = 1./s_ref*sum(panel_chords**2*widths)
    if (symmetry) mac = mac*2
    moment(:, :) = 0.
    do j=1,ny-1
      do i=1,nx-1
        arg1(:) = (bpts(i, j+1, :)+bpts(i, j, :))/2. - cg
        call cross(arg1(:), sec_forces(i, j, :), tmp)
        moment(j, :) = moment(j, :) + tmp
      end do
    end do
    moment = moment/mac
    if (symmetry) then
      moment(:, 1) = 0.
      moment(:, 2) = moment(:, 2)*2
      moment(:, 3) = 0.
    end if
    m = 0.
    do j=1,ny-1
      m = m + moment(j, :)
    end do
  end subroutine momentcalc_main
!  differentiation of compute_normals_main in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: s_ref mesh normals
!   with respect to varying inputs: s_ref mesh normals
!   rw status of diff variables: s_ref:in-zero mesh:incr normals:in-out
  subroutine compute_normals_main_b(nx, ny, mesh, meshb, normals, &
&   normalsb, s_ref, s_refb)
    implicit none
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: mesh(nx, ny, 3)
    real(kind=8) :: meshb(nx, ny, 3)
    real(kind=8) :: normals(nx-1, ny-1, 3), s_ref
    real(kind=8) :: normalsb(nx-1, ny-1, 3), s_refb
    integer :: i, j
    real(kind=8) :: norms(nx, ny), out(3)
    real(kind=8) :: normsb(nx, ny), outb(3)
    intrinsic sum
    intrinsic sqrt
    real(kind=8), dimension(3) :: arg1
    real(kind=8), dimension(3) :: arg1b
    real(kind=8), dimension(3) :: arg2
    real(kind=8), dimension(3) :: arg2b
    real(kind=8) :: tempb(3)
    do i=1,nx-1
      do j=1,ny-1
        arg1(:) = mesh(i, j+1, :) - mesh(i+1, j, :)
        arg2(:) = mesh(i, j, :) - mesh(i+1, j+1, :)
        call cross(arg1(:), arg2(:), out)
        normals(i, j, :) = out
        norms(i, j) = sqrt(sum(normals(i, j, :)**2))
      end do
    end do
    normsb = 0.0_8
    normsb = 0.5*s_refb
    outb = 0.0_8
    do i=nx-1,1,-1
      do j=ny-1,1,-1
        tempb = normalsb(i, j, :)/norms(i, j)
        normsb(i, j) = normsb(i, j) + sum(-(normals(i, j, :)*tempb/norms&
&         (i, j)))
        if (sum(normals(i, j, :)**2) .eq. 0.0_8) then
          normalsb(i, j, :) = tempb
        else
          normalsb(i, j, :) = 2*normals(i, j, :)*normsb(i, j)/(2.0*sqrt(&
&           sum(normals(i, j, :)**2))) + tempb
        end if
        normsb(i, j) = 0.0_8
        outb = outb + normalsb(i, j, :)
        normalsb(i, j, :) = 0.0_8
        arg1(:) = mesh(i, j+1, :) - mesh(i+1, j, :)
        arg2(:) = mesh(i, j, :) - mesh(i+1, j+1, :)
        arg1b = 0.0_8
        arg2b = 0.0_8
        call cross_b(arg1(:), arg1b(:), arg2(:), arg2b(:), out, outb)
        meshb(i, j, :) = meshb(i, j, :) + arg2b
        meshb(i+1, j+1, :) = meshb(i+1, j+1, :) - arg2b
        meshb(i, j+1, :) = meshb(i, j+1, :) + arg1b
        meshb(i+1, j, :) = meshb(i+1, j, :) - arg1b
      end do
    end do
    s_refb = 0.0_8
  end subroutine compute_normals_main_b
  subroutine compute_normals_main(nx, ny, mesh, normals, s_ref)
    implicit none
    integer, intent(in) :: nx, ny
    real(kind=8), intent(in) :: mesh(nx, ny, 3)
    real(kind=8), intent(out) :: normals(nx-1, ny-1, 3), s_ref
    integer :: i, j
    real(kind=8) :: norms(nx, ny), out(3)
    intrinsic sum
    intrinsic sqrt
    real(kind=8), dimension(3) :: arg1
    real(kind=8), dimension(3) :: arg2
    do i=1,nx-1
      do j=1,ny-1
        arg1(:) = mesh(i, j+1, :) - mesh(i+1, j, :)
        arg2(:) = mesh(i, j, :) - mesh(i+1, j+1, :)
        call cross(arg1(:), arg2(:), out)
        normals(i, j, :) = out
        norms(i, j) = sqrt(sum(normals(i, j, :)**2))
        normals(i, j, :) = normals(i, j, :)/norms(i, j)
      end do
    end do
    s_ref = 0.5*sum(norms)
  end subroutine compute_normals_main
!  differentiation of unit in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: u v
!   with respect to varying inputs: u v
! real functions
  subroutine unit_b(v, vb, u, ub)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8) :: vb(3)
    real(kind=8) :: u(3)
    real(kind=8) :: ub(3)
    real(kind=8) :: nm
    real(kind=8) :: nmb
    call norm(v, nm)
    vb(3) = vb(3) + ub(3)/nm
    nmb = -(v(3)*ub(3)/nm**2)
    ub(3) = 0.0_8
    vb(2) = vb(2) + ub(2)/nm
    nmb = nmb - v(2)*ub(2)/nm**2
    ub(2) = 0.0_8
    vb(1) = vb(1) + ub(1)/nm
    nmb = nmb - v(1)*ub(1)/nm**2
    ub(1) = 0.0_8
    call norm_b(v, vb, nm, nmb)
  end subroutine unit_b
! real functions
  subroutine unit(v, u)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(out) :: u(3)
    real(kind=8) :: nm
    call norm(v, nm)
    u(1) = v(1)/nm
    u(2) = v(2)/nm
    u(3) = v(3)/nm
  end subroutine unit
!  differentiation of norm in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: v norm_output
!   with respect to varying inputs: v
  subroutine norm_b(v, vb, norm_output, norm_outputb)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8) :: vb(3)
    real(kind=8) :: norm_output
    real(kind=8) :: norm_outputb
    real(kind=8) :: dot_prod, v1(3)
    real(kind=8) :: dot_prodb, v1b(3)
! need to create a copy of v here so the reverse mode ad works correctly
    v1 = v
!norm = sqrt(dot_product(v, v))
    call dot(v, v1, dot_prod)
    dot_prodb = 0.5*dot_prod**(-0.5)*norm_outputb
    call dot_b(v, vb, v1, v1b, dot_prod, dot_prodb)
    vb = vb + v1b
  end subroutine norm_b
  subroutine norm(v, norm_output)
    implicit none
    real(kind=8), intent(in) :: v(3)
    real(kind=8), intent(out) :: norm_output
    real(kind=8) :: dot_prod, v1(3)
! need to create a copy of v here so the reverse mode ad works correctly
    v1 = v
!norm = sqrt(dot_product(v, v))
    call dot(v, v1, dot_prod)
    norm_output = dot_prod**0.5
  end subroutine norm
!  differentiation of dot in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: dot_prod a
!   with respect to varying inputs: a b
  subroutine dot_b(a, ab, b, bb, dot_prod, dot_prodb)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8) :: ab(3), bb(3)
    real(kind=8) :: dot_prod
    real(kind=8) :: dot_prodb
    bb = 0.0_8
    ab(1) = ab(1) + b(1)*dot_prodb
    bb(1) = bb(1) + a(1)*dot_prodb
    ab(2) = ab(2) + b(2)*dot_prodb
    bb(2) = bb(2) + a(2)*dot_prodb
    ab(3) = ab(3) + b(3)*dot_prodb
    bb(3) = bb(3) + a(3)*dot_prodb
  end subroutine dot_b
  subroutine dot(a, b, dot_prod)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(out) :: dot_prod
    dot_prod = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
  end subroutine dot
!  differentiation of cross in reverse (adjoint) mode (with options i4 dr8 r8):
!   gradient     of useful results: a b c
!   with respect to varying inputs: a b c
  subroutine cross_b(a, ab, b, bb, c, cb)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8) :: ab(3), bb(3)
    real(kind=8) :: c(3)
    real(kind=8) :: cb(3)
    ab(1) = ab(1) + b(2)*cb(3)
    bb(2) = bb(2) + a(1)*cb(3)
    ab(2) = ab(2) - b(1)*cb(3)
    bb(1) = bb(1) - a(2)*cb(3)
    cb(3) = 0.0_8
    ab(3) = ab(3) + b(1)*cb(2)
    bb(1) = bb(1) + a(3)*cb(2)
    ab(1) = ab(1) - b(3)*cb(2)
    bb(3) = bb(3) - a(1)*cb(2)
    cb(2) = 0.0_8
    ab(2) = ab(2) + b(3)*cb(1)
    bb(3) = bb(3) + a(2)*cb(1)
    ab(3) = ab(3) - b(2)*cb(1)
    bb(2) = bb(2) - a(3)*cb(1)
    cb(1) = 0.0_8
  end subroutine cross_b
  subroutine cross(a, b, c)
    implicit none
    real(kind=8), intent(in) :: a(3), b(3)
    real(kind=8), intent(out) :: c(3)
    c(1) = a(2)*b(3) - a(3)*b(2)
    c(2) = a(3)*b(1) - a(1)*b(3)
    c(3) = a(1)*b(2) - a(2)*b(1)
  end subroutine cross
end module oas_main_b
